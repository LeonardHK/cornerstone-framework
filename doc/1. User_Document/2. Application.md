애플리케이션 작성법
===============

---

`내용이 많기 때문에 문서를 설명하는 방법에 대한 전략이 필요할듯. 일단 앱 제작 준비, 제작, 배포의 순으로 작성하는 챕터를 별도로 두는것은 어떨까 싶기도 함.`


Web을 구성하는 세 가지 요소
-----------------------
웹 페이지는 HTML, CSS, Javascript로 구성되며, 각각의 역할은 명확하게 구분되어 있다. HTML은 페이지의 내용을 기술하며, CSS는 페이지의 모양을 기술한다. Javascript는 사용자의 입력을 받아서 처리하고 결과를 만들어내는 기능을 수행한다.

파일 나누기
---------
한 파일에 HTML, CSS, Javascript를 모두 기술할 수도 있지만 다음과 같은 이유로 각각은 별도의 파일로 작성하는 것을 권장한다.

- 코드가 통합되어 있으면 프로젝트가 커지고 복잡해질 수록 관리하기 어렵다.
- 역할이 다른 코드는 따로 분리해야 코드가 간결해지고 이해하기 쉽다.
- 파일이 분리되어 있으면 여러 사람이 나누어서 작업하기 쉽다.
- 재사용성이 높아져 불필요한 반복을 하지 않게 된다.

디렉토리 구조
-----------
파일을 분류하는 기준에는 여러 가지가 있을 수 있으며, 애플리케이션에 가장 맞는 방법을 선택하는 것이 좋다.
일반적인 경우에는 다음과 같은 구조를 권장한다.

```
-+-- cornerstone
 +-- lib
 +-- style --+-- image
 +-- script -+-- model
 |           +-- view
 +-- template
```

각 디렉토리는 다음과 같은 용도로 사용한다.

- / : html 파일을 넣어둔다. Single-page Web App이라면 html 파일은 하나면 충분하고, 페이지가 여러개로 구성되어 있다면 페이지 수만큼 html 파일이 존재할 것이며 페이지가 많아지면 하위 디렉토리를 만들어 구조화한다.
- cornerstone : Framework 파일들을 넣어둔다.
- lib : 애플리케이션에서 필요로 하는 외부 라이브러리들을 넣어둔다.
- style : css 파일들을 넣어둔다. css 파일이 많아진다면 하위 디렉토리를 만들어 구조화한다.
- style/image : css에서 사용하는 이미지 파일들을 넣어둔다.
- script : 애플리케이션 메인 js 파일을 넣어둔다.
- script/model : Model에 해당하는 js 파일을 넣어둔다. Model이 많아진다면 하위 디렉토리를 만들어 구조화한다.
- script/view : View에 해당하는 js 파일을 넣어둔다. View가 많아진다면 하위 디렉토리를 만들어 구조화한다.
- template : template 파일들을 넣어둔다. 파일이 많아진다면 하위 디렉토리를 만들어 구조화한다.

`애플리케이션 메인, Model, View, Template에 대해서는 다음에 다시 설명하니 당장 이해가 안되더라도 넘어가도록 하자.`

Single-page Web App
-------------------
Single-page Web App은 하나의 페이지로 이루어진 웹 애플리케이션을 말한다. 페이지가 하나이므로 다른 페이지로 이동하거나 페이지 전체를 갱신하는 일 없이, 높은 사용성과 빠른 속도를 제공한다.

하지만, 하나의 페이지에 과도하게 많은 기능이 들어가면 페이지의 초기 로딩 시간이 길어지고 많은 메모리를 사용하게 되므로 적절하게 여러 페이지로 나누어 주는 것도 중요하다. 여러 개의 페이지로 구성할 경우 페이지가 전환될 때 메모리가 초기화되고 html, css, js들을 다시 로드해야 하므로 연관성이 깊은 기능들끼리 같은 페이지로 묶는 것이 중요하다.

자바스크립트 모듈화
---------------
애플리케이션이 많은 기능을 가질 수록 자바스크립트의 양이 많아지고 복잡해지는 것은 필연적이다. 자바스크립트를 역할과 용도에 따라 분할해서 관리해야 재사용성과 유지보수성이 높아지는 것은 당연하다. 이렇게 분할된 여러 개의 js 파일을 script 태그를 사용해서 일일이 로드하는 것도 한 방법이나 다음과 같은 문제점을 가지게 된다.

- 개발자가 사용하고자 하는 js 파일을 a.js라고 하고, a.js가 내부적으로 b.js를 사용하고 있다고 하면, 개발자는 a.js 만을 필요로 하더라도 b.js도 로드해야 한다. 개발자가 사용하고자 하는 js 파일간의 의존성을 모두 파악하고 있어야 한다.
- b.js를 먼저 로드하고, a.js를 로드해야 한다. script 태그를 작성하는 순서를 항상 고려해야 한다.
- 기본적으로 브라우저는 스크립트를 동기적으로 로드하기 때문에(하나씩 순서대로) js 파일이 많아지는 경우 필요 이상의 시간이 소요되며, 그 문제를 해결하기 위해 async 속성을 선택적으로 부여하는 것은 막노동에 가까운 일이 된다.

이 문제를 해결하기 위해 Cornerstone Framework는 require.js를 사용하여 자바스크립트 모듈화를 지원한다. require.js에 대해 자세히 알고 싶다면 http://requirejs.org 를 방문하기 바란다.

require.js를 사용하면 하나의 js 파일을 하나의 모듈로서 정의할 수 있고, 모듈간의 의존성을 명시할 수 있다. 개발자는 필요한 모듈 하나만 선택해서 사용하면 된다. require.js가 선택된 모듈과 의존성을 가지는 모듈을 모두 알아서 순서에 맞게 로드하고 가능한 한 병렬적으로 로드하기 때문에 시간이 필요 이상으로 소요되는 문제도 해결된다.

하나의 파일에서는 하나의 모듈만 정의할 수 있으며, 다음과 같이 define 함수로 모듈을 정의할 수 있다.

```
// model/user.js 파일에서 정의한 모듈
define( {
	name: '홍길동',
	age: 40,
	gender: '남'
} );
```

정의된 모듈을 사용하는 쪽에서는 require 함수를 사용한다.

```
require( [ 'model/user' ], function( user ) {
	// 40이 콘솔로 출력된다.
	console.log( user.age );
} );
```

require 함수의 첫번째 파라미터는 필요한 모듈명의 배열이다. 모듈명은 js 파일의 상대 경로명에서 확장자를 제외한 것이다. 두번째 파라미터는 필요한 모듈이 모두 다 로드되고 나면 실행되는 함수인데, 함수의 파라미터로 로드된 모듈들이 넘겨진다.

모듈을 정의할 때 모듈이 정적인 object가 아니라 매번 새로운 객체를 사용해야 한다면, define 함수를 사용할 때 object 대신 function을 사용한다.

```
define( function() {

	// 나이를 매번 계산
	var age = …;
	
	return {
		name: '홍길동',
		age: age,
		gender: '남'
	};
} );
```

정의하고자 하는 모듈이 다른 모듈을 사용해야 한다면, require 함수를 사용할 때와 같은 방식으로 사용 가능하다.

```
define( [ 'model/calculator' ], function( calculator ) {

	// 나이를 매번 계산
	var age = calculator.calculateAge();
	
	return {
		name: '홍길동',
		age: age,
		gender: '남'
	};
} );
```

모든 js 파일들은 모듈로 정의되는 것이 좋다.

HTML 만들기
----------
각 html 파일은 다음과 같이 작성된다.

```
<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="utf-8"/>
		<title>Sample App</title>
	</head>
	<body>
		<div class="container">
		(중략)
		</div>
		<script src="cornerstone/launcher.js" data-target="script/main"></script> 
	</body>
</html>
```

body 태그 내에 내용을 작성하고 가장 마지막에 script 태그를 사용함을 주목하자. 이렇게 하면 스크립트가 로딩이 되기 전에 페이지 렌더링을 시작하므로 화면이 더 빨리 뜨는 효과를 기대할 수 있다.

cornerstone/launcher.js는 애플리케이션을 실행시켜주는 스크립트이다. script 태그의 data-target 속성에 애플리케이션 메인의 모듈명을 지정한다.

작성해야 할 script 태그는 하나 뿐이다. 앞으로는 스크립트와 스타일시트를 로드하기 위해 link, script 태그를 직접 작성하지 않고, Framework에서 제공하는 기능을 사용하여 로드하도록 한다.

애플리케이션 메인
--------------
애플리케이션 메인은 페이지가 뜨고 가장 먼저 실행되는 애플리케이션의 자바스크립트 코드를 의미한다. 메인의 위치가 앞으로 다른 모듈들을 로드하는데 사용하는 경로의 기준 위치(BaseUrl)가 된다.

> 메인의 위치가 script 디렉토리이고 이 위치가 기준 위치가 되기 때문에 'model/user' 모듈명은 'script/model/user.js' 파일과 매핑된다.

다른 js 파일들과 마찬가지로 애플리케이션 메인 역시 require.js의 모듈로 정의되어야 한다. 다만 다른 모듈과 다른 점은 애플리케이션 메인 모듈에는 launch 함수가 반드시 존재해야 한다. cornerstone/launcher.js가 Framework을 초기화하고 모든 준비가 완료되면 애플리케이션 메인의 launch 함수를 실행시켜준다.

```
define( function() {
	return {
		launch: function() {
			// 애플리케이션의 시작점
		}
	};
} );
```

Require.js 설정
--------------
Cornerstone Framework은 기본적으로 많은 Open Source 라이브러리들을 내장하고 있으며, 그 라이브러리들도 모듈화되어 있기 때문에 모듈을 사용하는 것처럼 라이브러리를 사용할 수 있다. 기본적으로 제공하는 모듈은 다음과 같다.

모듈명 | 설명
:---- | :----
jquery | [jQuery core 라이브러리](http://jquery.com)
underscore | [Underscore](http://underscorejs.org/)
backbone | [Backbone](http://backbonejs.org/)

**`추가 명시 필요`**

기본적으로 제공하는 모듈 외에 추가해서 사용하는 라이브러리가 있다면 다음과 같은 설정을 통해서 모듈화할 수 있다.
설정 코드는 애플리케이션 메인의 define 앞쪽에 작성할 것을 권장한다.

```
requirejs.config( {
	// 긴 경로명을 짧게 줄여서 모듈명으로 사용할 수 있다.
	paths: {
		'libname': '../lib/somelibrary-1.0.0-min'
	},
	// 모듈의 의존성과 내용을 지정한다.
	shim: {
		'libname': {
			// 이 모듈은 jquery, underscore를 사용하기 때문에 jquery, underscore를 먼저 로드한다.
			deps: [ 'jquery', 'underscore' ],
			exports: function() {
				// require/define에서 이 모듈을 사용할 때 파라미터로 전달되는 내용
				// 여기서 this는 브라우저의 window 객체이다.
				return this.Somelibrary.noConflict();
			}
		}
	}
} );
```

MVC 패턴
-------
MVC(Model-View-Controller) 패턴은 애플리케이션을 Model, View, Controller로 분리해서 작성하는 패턴이다. 이런식으로 애플리케이션을 작성하면 사용자 인터페이스와 비즈니스 로직을 분리해서 서로 영향을 주지 않도록 작성할 수 있고 이는 비즈니스 로직 및 데이터의 재사용성을 높여준다. 각 요소는 다음과 같은 역할을 가진다.

- Model : 애플리케이션의 데이터 및 데이터와 관련된 로직을 관리한다.
- View : Model을 표현하는 방식을 결정하고 사용자 인터페이스를 담당한다.
- Controller : 사용자의 입력을 전달받아 처리하고, Model과 View에 명령을 내린다.

이 패턴을 그림으로 나타내면 다음과 같다.

![](http://prandy.iptime.org:3000/html5_framework/doc/blob?path=doc%2F1.+User_Document%2Fimages%2Fmvc.png)

`이미지 출처: http://blog.nodejitsu.com/scaling-isomorphic-javascript-code`

Cornerstone Framework은 MVC 패턴을 지원하기 위해 Backbone을 포함하고 있다. Backbone에 대해서 더 자세히 알고 싶으면 http://backbonejs.org 를 방문하기 바란다.

Backbone에서 사용하는 MVC 패턴은 전통적인 MVC 패턴과 조금 차이가 있는데, 아래 그림을 보면 잘 알 수 있다.

![](http://prandy.iptime.org:3000/html5_framework/doc/blob?path=doc%2F1.+User_Document%2Fimages%2Fbackbone-mvc.png)

`이미지 출처: http://blog.nodejitsu.com/scaling-isomorphic-javascript-code`

전통적인 MVC 패턴은 Controller가 Model을 조작하도록 되어 있지만, Backbone은 View가 직접 Model을 조작하는 것을 권장하고 있다. 이렇게 되면 Controller의 역할 중 상당 부분을 View가 가져가는 것이기 때문에 Controller가 가벼워지고 View가 무거워진다. 이것은 Model-View-Controller가 서로 균형을 이루는 이상적인 MVC 패턴은 아닐 수 있지만, 사용자의 입력을 View가 받아서 Controller로 전달하는 비효율을 제거해 코드의 양을 줄이고 성능을 향상시킬 수 있다. 

Model 만들기
-----------
다음과 같이 Backbone.Model의 extend를 사용하면 자신만의 Model 클래스를 정의하고 클래스의 인스턴스를 생성할 수 있다. defaults는 객체를 생성할 때 사용할 기본 속성값들을 의미하고, initialize는 객체가 생성되면 실행되는 생성자 함수이다.

```
var User = Backbone.Model.extend( {

	defaults: {
		name: '홍길동',
		age: 40
	},
	
	initialize: function() {
		// Model이 생성되면 실행된다.
		console.log( 'Created!' );
	}
} );

var user = new User();
```

Backbone 역시 require.js 모듈로 제공되므로 전체 코드는 다음처럼 될 것이다.

```
// model/user
define( [ 'backbone' ], function( Backbone ) {

	return Backbone.Model.extend( {

		defaults: {
			name: '홍길동',
			age: 40
		},
		
		initialize: function() {
			// Model이 생성되면 실행된다.
			console.log( 'Created!' );
		}
	} );
} );
```
```
require( [ 'model/user' ], function( User ) {
	var user = new User();
} );
```

Model 객체를 생성할 때 속성값들을 지정할 수 있고, get 메소드를 사용해 각각의 속성값을 구할 수 있다.

```
var user = new User( { name: '김철수' } );

console.log( user.get( 'name' ) );	// 콘솔에 '김철수' 출력
console.log( user.get( 'age' ) );	// 콘솔에 '40' 출력
```

set 메소드를 사용하면 속성값을 변경할 수 있다.

```
user.set( 'name', '박영수' );
user.set( { name: '박영수', age: 35 } );	// 여러 값을 한번에 변경 가능하다.
user.set( 'job', '컨설턴트' );	// 새로운 값을 지정할 수도 있다.
```

속성값이 변경되면 Model 객체에서 change 이벤트가 발생한다. on 또는 bind 메소드를 사용하면 이벤트가 발생했을 때 실행될 callback 함수를 지정할 수 있다. off 또는 unbind 메소드를 사용하면 지정된 callback 함수를 제거할 수 있다.

```
user.on( 'change', function() {
	// 아무 속성값이나 변경되면 실행된다.
} );

user.on( 'change:name', function() {
	// name 속성의 값이 변경되면 실행된다.
} );

// change 이벤트의 모든 callback을 제거한다.
user.off( 'change' );
```

Model의 고유한 식별자는 cid와 id의 두가지가 있다. cid는 Client ID라는 의미로 Model 객체가 생성될 때 자동으로 부여되는 식별자이고, id는 개발자가 직접 부여해 주는 식별자이다. 일반적으로 클라이언트에서 생성된 Model 객체는 일단 cid만을 가지게 되고 Model의 데이터가 서버에 저장이 되고 나면 데이터베이스에 저장할 때 만들어지는 Primary Key 값으로 Model의 id를 업데이트한다. 혹은 서버와 연동하지 않고 브라우저의 로컬 스토리지를 사용한다면 로컬 스토리지에 저장하면서 id를 부여할 수도 있다.

```
// 새로 만들어진 Model인지 검사한다.
if ( user.isNew() ) {
}
```

isNew 메소드는 Model이 새로 만들어진 것인지를 검사하는데, 새로 만들어진 Model 이라는 의미는 아직 서버에 저장되지 않았음을 의미한다. 그리고, id가 없으면 서버에 저장되지 않은 것으로 간주한다. 이것은 바꿔 말하면 Model을 서버에 저장한 후에는 반드시 id를 부여해야 함을 의미한다.


Collection 만들기
----------------
Collection은 Model의 정렬된 집합이다. Collection에 담겨 있는 Model의 속성이 변경되면 해당 Model 뿐 아니라 Collection에도 change 이벤트가 발생한다. Collection에 Model이 추가되거나 삭제되면 add, remove 이벤트가 발생한다.

자신만의 Collection 클래스를 정의하고 인스턴스를 생성하고 싶다면 extend 메소드를 사용한다.

```
var Users = Backbone.Collection.extend( {
	model: User
} );

// 빈 Collection 객체 생성
var users1 = new Users();

// Model들을 추가해서 Collection을 생성
var users2 = new Users( [ user1, user2, user3 ] );

// 객체를 추가해서 Collection을 생성, 각 객체는 User Model로 변환되서 추가된다.
var users3 = new Users( [
	{ name: '홍길동', age: 40 },
	{ name: '김철수', age: 35 },
	{ name: '이영수', age: 20 }
] );
```

Collection 객체를 생성한 후에 Model을 추가하고, 여러 가지 방법으로 Model을 찾을 수 있다. Colelction 내에서 Model들은 추가한 순서대로 유지된다.

```
users1.add( [
	{ name: '박철수', age: 25 },
	{ name: '최영희', age: 30 }
] );

// id로 Model을 찾는다. 
var user1 = users1.get( 35 );

// cid로 Model을 찾는다.
var user2 = users1.getByCid( 'c6' );

// 2번째 Model을 구한다.
var user3 = users1.at( 1 );

// age가 30인 Model들을 찾는다. (Model의 배열을 리턴한다.)
var users4 = users1.where( { age: 30 } );
```

View 만들기
----------
View의 역할은 사용자와 상호작용하는 것이다. 즉, View는 Model을 어떤 방식으로 사용자에게 보여줄지를 결정하고, 사용자의 입력을 받아서 어떻게 반응할지를 결정한다. 따라서 View는 특정 Model과 연결되어서 Model의 값이 변경될때마다 화면을 다시 그려주는 작업과 사용자의 입력으로 인해서 발생하는 이벤트를 처리하는 작업을 해야 한다.

자신만의 View 클래스를 정의하고 인스턴스를 생성하는 방법은 앞서 보았던 Model, Collection과 동일하다.

```
var UserView = Backbone.View.extend( {

	tagName: 'ul',
	className: 'user',
	
	render: function() {
		// View를 그리는 코드를 작성한다.
	}
	
} );

var userView = new UserView( { model: user } );
```

모든 View 객체는 DOM element를 가진다. 이 DOM element는 실제로 페이지에 존재할 수도 있고 아닐 수도 있다. 위의 예에서 userView 객체는 `<ul class="user"></ul>` 에 해당하는 DOM element를 자동으로 생성해서 가지게 되지만 아직 페이지에 삽입하지 않았으므로 보여지지는 않는다. 만약에 tagName을 지정하지 않는다면 div 를 생성한다.

el 속성을 지정하게 되면 DOM element를 새로 만들지 않고 페이지에 존재하는 DOM element를 찾아서 사용한다. el 속성을 지정할 때는 jQuery의 selector를 사용한다.

```
var UserView = Backbone.View.extend( {

	el: 'section#list-section',
	
	render: function() {
		// View를 그리는 코드를 작성한다.
	}
} );
```

이 DOM element는 el 또는 $el 속성을 사용해서 구할 수 있다.

```
// userView의 DOM element를 구한다.
var e1 = userView.el;

// userView의 DOM element에 해당하는 jQuery 객체를 구한다.
var e2 = userView.$el;
```

실제로 View를 그리는 작업은 render 메소드에서 일어난다. render 메소드에서는 Model 객체를 사용해서 HTML을 생성한 후 this.el을 갱신하고, 메소드의 끝에서 this를 리턴해 주어야 한다. 이것은 체인 호출(chained call)을 가능하게 한다.

```
var UserView = Backbone.View.extend( {

	tagName: 'ul',
	className: 'user',
	
	render: function() {
		this.$el.html( '<span>' + this.model.get( 'age' ) '</span>' );
		return this;
	}
} );

var userView = new UserView( { mode: user } );

// View 객체를 그린 후 DOM element를 페이지에 삽입한다.
$( '#user-list' ).append( userView.render().el );
```

위 예는 render 메소드의 동작 방식을 설명하기 위해 단순하게 작성된 것이며, 저렇게 HTML 코드가 render 함수 내에 하드코딩 되는 것은 권장하지 않는다. Model 객체의 값으로 HTML을 만들어내는 작업은 나중에 설명될 템플릿을 사용하게 될 것이다.

사용자의 이벤트를 처리하려면 다음과 같이 events 속성을 지정한다.

```
var UserView = Backbone.View.extend( {
	
	el: 'section#list-section',
	
	events: {
		'dblclick': 'open',
		'click .item': 'select',
		'mouseover .title .date': 'showTooltip'
	},
	
	open: function() {
		// section#list-section을 더블클릭하면 실행된다.
	},
	
	select: function() {
		// section#list-section 하위의 .item을 클릭하면 실행된다.
	},
	
	showTooltip: function() {
		// section#list-section 하위의 .title 또는 .date 위에 마우스를 올리면 실행된다.
	}
} );
```

events 속성은 'event selector': 'callback' 의 형식으로 기술된다. selector를 지정하지 않으면 el(View의 DOM element)에서 발생하는 이벤트를 의미하게 된다.

Form View
---------


Validation
----------
Form 유효성 검사에 대해 설명


동기화
-----
### 서버와 동기화


### 로컬 스토리지와 동기화





Fragment와 라우팅
---------------
여러 화면이 존재하는 Single-page Web App을 만든다고 가정해 보자. 다른 화면으로 이동할 때는 실제로 페이지를 전환하지 않고 AJAX를 사용해 페이지의 일부분을 다시 렌더링하게 될 것이다. 이 경우 실제로 페이지가 전환되는 것이 아니므로 현재 URL에는 변화가 없다. 즉, 각각의 화면은 고유한 URL을 가질 수 없고, 따라서 각 화면에 대한 하이퍼링크를 제공하거나 브라우저에 북마크로 등록하거나 하는 작업이 불가능해지며 브라우저의 Back/Forward 버튼을 사용해서 페이지 이동을 할 수도 없다. 이것은 웹으로서의 사용성을 해치는 일이기 때문에 해결책이 필요하다.

URL에 부가적인 정보를 더 담는 방법으로 Query가 있다. 웹 개발 경험이 있다면 누구나 한번쯤은 다음과 같이 물음표(?)를 사용하여 파라미터를 추가해 보았을 것이다.

```
http://www.example.org/foo.html?bar=1
```

또 다른 방법으로는 Fragment가 있다. 이것은 Hash mark(#)를 사용하여 현재 페이지의 특정 위치를 가리킨다. Hash mark 뒷부분의 문자열을 Fragment identifier라고 한다.

```
http://www.example.org/foo.html#bar
```

Query와 Fragment는 결정적인 차이점을 가지고 있는데, Query는 서버에서 처리되지만 Fragment는 클라이언트(웹 브라우저)에서 처리된다는 것이다. 즉, Fragment가 변경되어도 브라우저는 서버에 요청을 다시 보내지 않는다. 그래서 이점을 이용하여 Single-page Web App의 화면마다 다른 Fragment identifier를 부여하면, 결국 화면마다 고유한 URL을 가질 수 있게 되고 URL이 바뀌어도 페이지가 전환되지 않기 때문에 Single-page Web App을 유지할 수 있다.

`HTML5의 Push State를 사용하면 Fragment를 사용하지 않고도 이 문제를 해결할 수 있으나, Push State는 IE9 이하의 브라우저와 안드로이드의 기본 브라우저에서 제대로 지원하지 않으므로 사용하지 않는다.`

따라서 Fragment를 사용하면 애플리케이션에서는 페이지가 처음 실행되거나 Fragment identifier가 변경될 경우 그에 맞는 화면을 렌더링하는 작업을 해 주면 된다. 이를 간편하게 할 수 있도록 Backbone에서는 Router를 제공한다.

일반적으로 웹에서 라우팅은 URL에 패턴에 따라서 다른 모듈을 실행하도록 분기시키는 작업을 의미한다. Backbone의 Router는 Fragment identifier의 패턴에 따라서 지정된 함수를 실행하거나 이벤트를 발생시킨다.

```
var MainRouter = Backbone.Router.extend( {
	
	// Fragment identifier의 패턴과 함수의 매핑
	routes: {
		'': 'list',				// # or #이 없는 경우
		'list': 'list',			// #list
		'add': 'add',			// #add
		'detail/:id', 'detail'	// #detail/5
	},
	
	list: function() {
		// URL이 # 또는 #list로 끝나거나 #이 없는 경우 실행된다.
	},
	
	add: function() {
		// URL이 #add로 끝나면 실행된다.
	},
	
	detail: function( id ) {
		// URL 패턴에서 :로 시작되는 부분은 파라미터를 의미한다.
	}
} );

new MainRouter();

// Fragment identifier의 변경을 감지하고 라우팅을 처리한다.
Backbone.history.start();
```

위의 예에서 보는 것과 같이 동적으로 변화되는 부분은 :[변수명]의 형태로 쓰면 함수의 파라미터로 받을 수 있다.
라우팅 코드는 애플리케이션 메인의 launch 함수 내에 작성되는 것이 가장 적합하다.


### Optimization
필요한가?

### Server-side를 작성할 때 주의점

* RESTful
* Validation
* Security



저장소
-----------------
Model에서 localstroage crud 연계 방법 설명

템플릿
-----------------
Handlebar 템플릿 엔진에 대한 장점 및 사용 방법 설명
정적인 부분과 동적인 부분을 구분

레이아웃
-----------------
View에서 제공되는 레이아웃을 사용할 때 장점 및 방법 설명

멀티페이지
-----------------
View에서 제공되는 멜터페이지을 사용할 때 장점 및 방법 설명

리소스 로더
-----------------
CSS도 Lazy loading을 통해 얻을 수 있는 장점과 사용 및 활용 방법 설명

이벤트
-----------------
### 이벤트 핸들링
프레임워크를 통해 click과 같은 이벤트 사용시 장점 및 방법 설명

### 모바일 특화 이벤트
터치 기반에 특화된 이벤트 사용 방법

보안
-----------------
보안과 관련된 내용

소켓통신
-----------------
소켓통신을 하기 위한 방법

예외처리
-----------------
에러에 대한 공통적인 규칙을 설명하고 어떻게 핸들링하는지

패키징
-----------------
만들어진 App을 r.js로 패키징하는 방법 설명
