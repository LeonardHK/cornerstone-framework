<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>widget.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/RangeInput.html">RangeInput</a></li>
            
                <li><a href="..&#x2F;classes/Touch.html">Touch</a></li>
            
                <li><a href="..&#x2F;classes/Widget.html">Widget</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: widget.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*
 *  Project: SKT HTML5 Framework
 *  CodeName : CornerStone
 *  FileName : widget.js
 *  Description: widget.js은 각종 플러그인들의 wrapping, 커스텀 플러그인, 전후 처리를 통한 최적화 및 공통적인 터치 기능 등과 같은 작업을 처리한다.
 *  Author: 김우섭
 *  License :
 *&#x2F;

&#x2F;&#x2F; 세미콜론은 패키징 작업시 앞쪽 스크립트가 닫지 않은 경우 오류를 사전에 막기 위함
;
(function (root, doc, factory) {
    if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {
        &#x2F;&#x2F; AMD. Register as an anonymous module.
        define([ &quot;jquery&quot; ], function ($) {
            factory($, root, doc);
        });
    } else {
        &#x2F;&#x2F; Browser globals
        factory(root.jQuery, root, doc);
    }
}(this, document, function (jQuery, window, document, undefined) {
    (function ($, window, undefined) {
        var pluginPrefix = &quot;&quot;,
            isDebug = true,
            pluginCollection = {
                &#x2F;&#x2F; Bootstrap
&#x2F;&#x2F;                &quot;alert&quot;:true, &quot;button&quot;:true, &quot;carousel&quot;:true, &quot;collapse&quot;:true, &quot;dropdown&quot;:true,
&#x2F;&#x2F;                &quot;modal&quot;:true, &quot;popover&quot;:true, &quot;scrollspy&quot;:true, &quot;tab&quot;:true, &quot;tooltip&quot;:true,
&#x2F;&#x2F;                &quot;typeahead&quot;:true,
                &#x2F;&#x2F; Custom
                &quot;sign&quot;:true, &quot;motioncapcha&quot;:true, &quot;loading&quot;:false, &quot;fixedbar&quot;:false, &quot;rangeinput&quot;:false
            },
            featuredpluginCollection = {
                &quot;media&quot;:true, &quot;editor&quot;:true, &quot;datatables&quot;:true, &quot;datapicker&quot;:true, &quot;listview&quot;:true,
                &quot;scrollview&quot;:true, &quot;chart&quot;:true
            };

        function logger() {
            console.log(arguments.callee.caller.line, arguments);
        }

        &#x2F;**
         * Widget 은 폼, 컴포넌트, 플러그인, 피처드플러그인, 제스처로 구성되어 있다.
         * @name Widget
         * @class Widget
         * @constructor
         *&#x2F;
        var Widget = function () {
        };

        Widget.prototype.init = function () {
            this.registryPlugin();
            &#x2F;&#x2F;this.registryFeaturedPlugin();
            this.common.touch();
            this.common.getDeviceType();
        };

        Widget.prototype.registryPlugin = function () {
            for (var idx in pluginCollection) {
                &#x2F;&#x2F;noinspection JSUnfilteredForInLoop
                var orginName = idx;
                var isNeededInit = false;

                &#x2F;&#x2F; 플러그인 이름에 대문자-&gt;소문자, 간소화 등을 처리
                if (idx === &quot;motioncapcha&quot;) {
                    orginName = &quot;motionCaptcha&quot;;
                } else if (idx === &quot;sign&quot;) {
                    orginName = &quot;jSignature&quot;;
                } else {
                    isNeededInit = true;
                }

                &#x2F;&#x2F; Wrapping이 필요한 플러그인들만을 기존 플러그인명을 그대로 사용하기 위해서 prefix old로 재정의 한다.
                &#x2F;&#x2F;noinspection JSUnfilteredForInLoop
                if (pluginCollection[idx]) {
                    $.fn[&quot;old&quot; + orginName] = $.fn[orginName];

                    &#x2F;&#x2F; jSignature 플러그인은 내부적으로도 $.jSignature 사용하므로 isNeededInit으로 플러그인 제거를 방지
                    if (isNeededInit) {
                        $.fn[orginName] = undefined;
                    }
                }

                &#x2F;&#x2F; PluginCollection에 정의된 목록대로 플러그인들을 등록한다.
                &#x2F;&#x2F; 반복문에선 function 종료된 시점인 경우 반복문의 마지막 값이 저장되는 Closure 특징으로 한번 더 Closure를 추가함.
                var widget = new Widget();
                if (typeof widget[pluginPrefix + idx][&quot;dataAPI&quot;] === &quot;function&quot;) {
                    widget[pluginPrefix + idx].dataAPI();
                }

                $.fn[pluginPrefix + idx] = (function (name) {
                    return function (options) {
                        return this.each(function () {
                            widget[name].init(options, this);
                        });
                    }
                })(pluginPrefix + idx);
            }
        };

        Widget.prototype.registryFeaturedPlugin = function () {
&#x2F;&#x2F;            _debugger(featuredpluginCollection);
        };

        Widget.prototype.common = {
            init:function (target, options, element) {
                if (typeof options === &quot;string&quot;) {
                    target.options = options;
                } else {
                    target.options = $.extend({}, target.options, options);
                }

                target.element = element;
                target.$element = $(element);

                target._build();
            },
            pseudo: function() {

            },
            touch:function () {

                function getTouchPageXY(e) {
                    if (e.type.match(&quot;touch.*&quot;)) {
                        touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
                        e.pageX = touch.pageX;
                        e.pageY = touch.pageY;
                    }
                }

                $(document).on(&quot;touchstart mousedown touchmove mousemove touchend mouseup&quot;, function (e) {
                    if (e.type.match(&quot;touch.*&quot;)) {
                        var touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
                        e.pageX = touch.pageX;
                        e.pageY = touch.pageY;
                    }
                });

                &#x2F;**
                 * 드래그 이벤트
                 * 설정:
                 * x: true, &#x2F;&#x2F; 수평 드래그 활성화 여부
                 * y: true, &#x2F;&#x2F; 수직 드래그 활성호 여부
                 * drag: true &#x2F;&#x2F; 드래그 이벤트 실행 여부
                 *
                 * Events: dragStart, drag, dragEnd.
                 * Examples$(&quot;.myelementent&quot;).drag({y: false}).on(&quot;drag&quot;, function(event, x, y) {
                 *  &#x2F;&#x2F; do your custom thing
                 *  });
                 *&#x2F;
                $.fn.drag = function (conf) {
                    var doc, draggable;
                    conf = $.extend({x:true, y:true, drag:true}, conf);
                    doc = doc || $(document).on(&quot;mousedown mouseup touchstart touchend&quot;, function (e) {
                        var touch;
                        var el = $(e.target);

                        &#x2F;&#x2F; 마우스와 터치 이벤트가 시작하고 타겟 엘리먼트가 드래그인 경우
                        if (e.type.match(&quot;mousedown|touchstart&quot;) &amp;&amp; el.data(&quot;drag&quot;)) {

                            var offset = el.position(),
                                x0 = e.pageX - offset.left,
                                y0 = e.pageY - offset.top,
                                start = true;

                            doc.on(&quot;mousemove.drag touchmove.drag&quot;, function (e) {
                                var x = e.pageX - x0,
                                    y = e.pageY - y0,
                                    props = {};

                                if (conf.x) {
                                    props.left = x;
                                }
                                if (conf.y) {
                                    props.top = y;
                                }

                                if (start) {
                                    el.trigger(&quot;dragStart&quot;);
                                    start = false;
                                }

                                if (conf.drag) {
                                    el.css(props);
                                }

                                el.trigger(&quot;drag&quot;, [y, x]);
                                draggable = el;
                            });

                            e.preventDefault();
                        } else {

                            try {
                                if (draggable) {
                                    draggable.trigger(&quot;dragEnd&quot;);
                                }
                            } finally {
                                &#x2F;&#x2F; 이벤트 제거
                                doc.off(&quot;mousemove.drag touchmove.drag&quot;);
                                draggable = null;
                            }
                        }

                    });

                    return this.data(&quot;drag&quot;, true);
                };
            },
            replaceAll:function (target, searchText, replaceText) {
                logger(typeof target);
                if (typeof target === &quot;string&quot;) {
                    target.replace(new RegExp(searchText, &quot;gi&quot;), replaceText);
                }
            },
            &#x2F;&#x2F; 터치 컨테이너와 포인터의 CSS 준비
            prepareTouchCss:function (element) {
                var vendors = [&#x27;webkit&#x27;, &#x27;moz&#x27;, &#x27;ms&#x27;, &#x27;o&#x27;, &#x27;&#x27;];
                var css_props = {
                    &quot;userSelect&quot;:&quot;none&quot;,
                    &quot;touchCallout&quot;:&quot;none&quot;,
                    &quot;userDrag&quot;:&quot;none&quot;,
                    &quot;tapHighlightColor&quot;:&quot;rgba(0,0,0,0)&quot;
                };

                var prop = &#x27;&#x27;;
                for (var i = 0; i &lt; vendors.length; i++) {
                    var stylePropert = &quot;&quot;;
                    for (var p in css_props) {
                        prop = p;
                        if (vendors[i]) {
                            prop = vendors[i] + prop.substring(0, 1).toUpperCase() + prop.substring(1);
                        }
                        stylePropert += prop + &quot;:&quot; + css_props[p] + &quot;; &quot;;
                    }

                    element.attr(&quot;style&quot;, element.attr(&quot;style&quot;) + &quot;;&quot; + stylePropert);
                }

            },
            &#x2F;&#x2F; UserAgent 정보를 통해 디바이스 구분
            getDeviceType:function () {
                if (navigator.userAgent.toUpperCase().match(&quot;IOS&quot;)) {
                    $.browser.os = &quot;IOS&quot;;
                    $.browser.version = 4;
                } else if (navigator.userAgent.toUpperCase().match(&quot;IOS&quot;)) {
                    $.browser.os = &quot;ANDROID&quot;;
                }
            }
        };

        &#x2F;**
         * alert 은 화면에 경고 메세지를 표현하기 위한 플러그인이다.
         *
         * @constructor
         * @name alert
         * @param {string} options - 옵션값 (close)
         * @param {object} element - 타겟 엘리먼트
         * @example
         * &lt;pre&gt;
         *     $(&quot;.alert&quot;).alert();
         * &lt;&#x2F;pre&gt;
         *&#x2F;
        Widget.prototype.alert = {
            init:function (options, element) {
                this.widget = new Widget();
                this.widget.common.init(this, options, element);
            },
            options:{ },
            _before:function () {
                logger(this.$element);
            },
            _build:function () {
                this._before();
                &#x2F;&#x2F;noinspection JSUnresolvedFunction
                logger(this.options);
                this.$element.oldalert(this.options);
                this._done();
            },
            _done:function () {

            }
        };

        &#x2F;**
         * button 은 버튼에 toggle 기능을 추가한 플러그인이다.
         *
         * @constructor
         * @name button
         * @param {string} options - 토글시 노출시킬 텍스트 (toggle, loading, reset, 사용자정의 문자)
         * @param {object} element - 타겟 엘리먼트
         * @example
         * &lt;pre&gt;
         *     $(&#x27;.nav-tabs&#x27;).button()
         * &lt;&#x2F;pre&gt;
         *&#x2F;
        Widget.prototype.button = {
            init:function (options, element) {
                this.widget = new Widget();
                this.widget.common.init(this, options, element);
            },
            options:{ },
            _before:function () {

            },
            _build:function () {
                this._before();
                &#x2F;&#x2F;noinspection JSUnresolvedFunction
                this.$element.oldbutton(this.options);
                this._done();
            },
            _done:function () {

            }
        };

        &#x2F;**
         * 캐러셀은 이미지 슬라이더 플러그인으로 CSS3 효과를 추가해 다양한 형태의 화면전환를 연출시킨다.
         *
         * @constructor
         * @name carousel
         * @param {object, string} options - 이미지 슬라이더 옵션 지정 (cycle, pause, number, prev, next, default{interval: 4000, pause: &quot;hover&quot;})
         * @param {object} element - 타겟 엘리먼트
         * @example
         *     $(&#x27;.carousel&#x27;).carousel()
         *
         *     Event    Description
         *     slide    슬라이드 이벤트가 시작할 때 발생
         *     slid 슬리이드 이벤트가 완료했을 때 발생
         *
         *     TODO 반응형 웹사이트에 대응하기 위하 유동적으로 높이와 폭을 잡아야하며,
         *     background-size 역시 그 비율에 맞게 조절이 필요하다.
         *&#x2F;
        Widget.prototype.carousel = {
            init:function (options, element) {
                this.widget = new Widget();
                this.widget.common.init(this, options, element);
            },
            options:{

            },
            _before:function () {

            },
            _build:function () {
                this._before();
                this.$element.oldcarousel(this.options);
                this._done();
            },
            _done:function () {

            },
            swipeSlider:function () {

            }
        };

        &#x2F;**
         * 콜라스는 아코디언으로 수직으로 접기&#x2F;펼치기 기능을 하는 플러그인이다.
         * @name collapse
         *&#x2F;
        Widget.prototype.collapse = {
            init:function (options, element) {
                this.widget = new Widget();
                this.widget.common.init(this, options, element);
            },
            options:{ },
            _before:function () {

            },
            _build:function () {
                this._before();
                this.$element.oldcollapse(this.options);
                this._done();
            },
            _done:function () {

            }
        };

        &#x2F;**
         * dropdown은 메뉴와 같은 네비게이션에서 하위 메뉴를 노출 시킬 때 사용 되는 플러그인이다.
         * @name dropdown
         *&#x2F;
        Widget.prototype.dropdown = {
            init:function (options, element) {
                this.widget = new Widget();
                this.widget.common.init(this, options, element);
            },
            options:{ },
            _before:function () {

            },
            _build:function () {
                this._before();
                &#x2F;&#x2F;noinspection JSUnresolvedFunction
                this.$element.olddropdown(this.options);
                this._done();
            },
            _done:function () {

            }
        };

        &#x2F;**
         * modal은 팝업 형태로 노출되는 플러그인이다.
         * @name modal
         * TODO 오페라 및 모바일에서 비정상적인 작동과, 성능이 저하되는 문제가 발생하므로 조치가 필요하다.
         *&#x2F;
        Widget.prototype.modal = {
            init:function (options, element) {
                this.widget = new Widget();
                this.widget.common.init(this, options, element);
            },
            options:{ },
            _before:function () {
                logger(&quot;_before modal&quot;);
            },
            _build:function () {
                this._before();
                this.plugin = this.$element.oldmodal(this.options);
                this._done();
            },
            _done:function () {
            }
        };

        &#x2F;**
         * popover
         * @name popover
         *&#x2F;
        Widget.prototype.popover = {
            init:function (options, element) {
                this.widget = new Widget();
                this.widget.common.init(this, options, element);
            },
            options:{ },
            _before:function () {
                logger(&quot;_before popover&quot;);
            },
            _build:function () {
                this._before();
                &#x2F;&#x2F;noinspection JSUnresolvedFunction
                this.$element.oldpopover(this.options);
                logger(&quot;_build popover&quot;);
                this._done();
            },
            _done:function () {
                logger(&quot;_done popover&quot;);
            },
            dataAPI:function () {
                var self = this;
                $(function () {
                    $(&#x27;body&#x27;).on(&quot;click.popover.data-api&quot;, &quot;[data-trigger=&#x27;click&#x27;]&quot;,function (e) {
                        var $this = $(this)
                            , href = $this.attr(&#x27;href&#x27;)
                            , option = $this.data(&#x27;popover&#x27;) ? &#x27;toggle&#x27; : $.extend({ remote: !&#x2F;#&#x2F;.test(href) &amp;&amp; href }, $this.data(), $this.data());

                        e.preventDefault();
                        $this.popover(option);
                    });

                });
            }
        };

        &#x2F;**
         * scrollspy
         * @name scrollspy
         *&#x2F;
        Widget.prototype.scrollspy = {
            init:function (options, element) {
                this.widget = new Widget();
                this.widget.common.init(this, options, element);
            },
            options:{ },
            _before:function () {

            },
            _build:function () {
                this._before();
                this.$element.oldscrollspy(this.options);
                this._done();
            },
            _done:function () {

            }
        };

        &#x2F;**
         * 탭은
         * @name tab
         *&#x2F;
        Widget.prototype.tab = {
            init:function (options, element) {
                this.widget = new Widget();
                this.widget.common.init(this, options, element);
            },
            options:{ },
            _before:function () {

            },
            _build:function () {
                this._before();
                this.$element.oldtab(this.options);
                this._done();
            },
            _done:function () {

            }
        };

        &#x2F;**
         * tooltip
         * @name tooltip
         *&#x2F;
        Widget.prototype.tooltip = {
            init:function (options, element) {
                this.widget = new Widget();
                this.widget.common.init(this, options, element);
            },
            options:{ },
            _before:function () {

            },
            _build:function () {
                this._before();
                this.$element.oldtooltip(this.options);
                this._done();
            },
            _done:function () {

            }
        };

        &#x2F;**
         * typeahead는 입력창에 텍스트 입력시 관련 단어들이 노출되는 플러그인이다.
         *
         * @constructor
         * @param {object, string} options - 이미지 슬라이더 옵션 지정 (cycle, pause, number, prev, next, default{interval: 4000, pause: &quot;hover&quot;})
         * @param {object} element - 타겟 엘리먼트
         * @example
         *     $(&#x27;.carousel&#x27;).carousel()
         *
         *     Event    Description
         *     slide    This event fires immediately when the slide
         *     instance method is invoked.
         *
         *     slid    This event is fired when the carousel has completed
         *     its slide transition.
         *
         *     TODO 반응형 웹사이트에 대응하기 위하 유동적으로 높이와 폭을 잡아야하며,
         *     background-size 역시 그 비율에 맞게 조절이 필요하다.
         *&#x2F;
        Widget.prototype.typeahead = {
            init:function (options, element) {
                this.widget = new Widget();
                this.widget.common.init(this, options, element);
            },
            options:{ },
            _before:function () {

            },
            _build:function () {
                this._before();
                this.$element.oldtypeahead(this.options);
                this._done();
            },
            _done:function () {

            }
        };

        &#x2F;**
         * sign
         * @name sign
         * TODO 터치 이벤트 중복 문제 해결필
         *&#x2F;
        Widget.prototype.sign = {
            init:function (options, element) {
                this.widget = new Widget();
                this.widget.common.init(this, options, element);
            },
            options:{ },
            _before:function () {

            },
            _build:function () {
                this._before();
                this.$element.oldjSignature(this.options);
                this._done();
            },
            _done:function () {

            }
        };

        &#x2F;**
         * Motion Capcha 은 Form 전송시(로그인, 회원가입 등) 스팸 방지를 위한 터치 기반 Capcha 플러그인이다.
         * @name motioncapcha
         * TODO 갤럭시 S3 기본 브라우저에서 로딩 후 첫화면이 아닌 스크롤로 이동해서 보여지는 경우 모션이 표현 되지 않는 문제.
         *&#x2F;
        Widget.prototype.motioncapcha = {
            init:function (options, element) {
                this.widget = new Widget();
                this.widget.common.init(this, options, element);
            },
            options:{ },
            _before:function () {

            },
            _build:function () {
                this._before();
                this.$element.oldmotionCaptcha(this.options);
                this._done();
            },
            _done:function () {

            }
        };

        &#x2F;**
         * loading
         * @name loading
         *&#x2F;
        Widget.prototype.loading = {
            init:function (options, element) {
                this.widget = new Widget();
                this.widget.common.init(this, options, element);
            },
            options:{ },
            _before:function () {

            },
            _build:function () {
                this._before();
&#x2F;&#x2F;            this.$element.oldmotionCaptcha(this.options);
                this._done();
            },
            _done:function () {

            }
        };

        &#x2F;**
         * fixedbar
         * @name fixedbar
         *&#x2F;
        Widget.prototype.fixedbar = {
            init:function (options, element) {
                this.widget = new Widget();
                this.widget.common.init(this, options, element);
            },
            options:{ },
            _before:function () {
            },
            _build:function () {
                this._before();
&#x2F;&#x2F;                this.$element.oldalert(this.options);
                this._done();
            },
            _done:function () {

            },
            fixedbar:function () {

            }
        };

        &#x2F;**
         * slider
         * @name slider
         * TODO input 태그에 pseudo 클래스 :before, :after를 사용은 유효성에 위배되므로 별개 UI(div)로 표현함.
         * http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;4574912&#x2F;css-content-generation-before-input-elementents
         * 안드로이드 디바이스 GC로 인한 성능저하 문제 해결 필요 e.g. width 증감, input value 증감
         *&#x2F;
        Widget.prototype.rangeinput = {
            init:function (options, element) {
                this.widget = new Widget();
                this.widget.common.init(this, options, element);
            },
            options:{ },
            _before:function () {

            },
            _build:function () {
                this._before();
                this._create();
                this._done();
            },
            _done:function () {
            },
            _create:function () {
                var defaultOptions = {
                    min:0,
                    max:100,
                    step:&#x27;any&#x27;,
                    steps:0,
                    value:0,
                    precision:undefined,
                    vertical:0,
                    keyboard:false,
                    progress:false,
                    speed:100,
                    inputShow:false,
                    css:{
                        input:&#x27;range&#x27;,
                        slider:&#x27;slider&#x27;,
                        progress:&#x27;progress&#x27;,
                        handle:&#x27;handle&#x27;
                    }
                };

                function round(value, precision) {
                    var n = Math.pow(10, precision);
                    return Math.round(value * n) &#x2F; n;
                }

                function dim(el, key) {
                    var v = parseInt(el.css(key), 10);
                    if (v) {
                        return v;
                    }
                    var s = el[0].currentStyle;
                    return s &amp;&amp; s.width &amp;&amp; parseInt(s.width, 10);
                }

                function hasEvent(el) {
                    var e = el.data(&quot;events&quot;);
                    return e &amp;&amp; e.onSlide;
                }

                function RangeInput(input, conf) {
                    var self = this,
                        css = conf.css,
                        root = $(&quot;&lt;div&gt;&lt;div&#x2F;&gt;&lt;a href=&#x27;#&#x27;&#x2F;&gt;&lt;&#x2F;div&gt;&quot;).data(&quot;rangeinput&quot;, self),
                        vertical,
                        value, &#x2F;&#x2F; current value
                        origo, &#x2F;&#x2F; handle&#x27;s start point
                        len, &#x2F;&#x2F; length of the range
                        pos;				&#x2F;&#x2F; current position of the handle

                    &#x2F;&#x2F; UI 엘리먼트 생성
                    input.before(root);

                    var handle = root.addClass(css.slider).find(&quot;a&quot;).addClass(css.handle),
                        progress = root.find(&quot;div&quot;).addClass(css.progress);

                    $.each(&quot;min,max,step,value&quot;.split(&quot;,&quot;), function (i, key) {
                        var val = input.attr(key);
                        if (parseFloat(val)) {
                            conf[key] = parseFloat(val, 10);
                        }
                    });

                    var range = conf.max - conf.min,
                        step = conf.step == &#x27;any&#x27; ? 0 : conf.step,
                        precision = conf.precision;

                    if (precision === undefined) {
                        precision = step.toString().split(&quot;.&quot;);
                        precision = precision.length === 2 ? precision[1].length : 0;
                    }

                    &#x2F;&#x2F; Replace built-in range input (type attribute cannot be changed)
                    if (input.attr(&quot;type&quot;) == &#x27;range&#x27;) {
                        var def = input.clone().wrap(&quot;&lt;div&#x2F;&gt;&quot;).parent().html(),
                            clone = $(def.replace(&#x2F;type&#x2F;i, &quot;type=tel data-orig-type&quot;));

                        clone.val(conf.value);
                        input.replaceWith(clone);
                        input = clone;
                    }

                    input.addClass(css.input);

                    &#x2F;&#x2F; input UI를 노출시키고 싶지 않은 경우 처리
                    if (!conf.inputShow) {
                        input.css({
                            position:&quot;absolute&quot;,
                            left:&quot;-10000em&quot;
                        });
                    }

                    var fire = $(self).add(input), fireOnSlide = true;

                    &#x2F;**
                     * @param evt types include: click, keydown, blur and api (setValue call)
                     * @param isSetValue when called trough setValue() call (keydown, blur, api)
                     * range 슬라이드 함수
                     * 수직 슬라이드 구현예정
                     *&#x2F;
                    function slide(evt, x, val, isSetValue) {

                        &#x2F;&#x2F; calculate value based on slide position
                        if (val === undefined) {
                            val = x &#x2F; len * range;

                            &#x2F;&#x2F; x is calculated based on val. we need to strip off min during calculation
                        } else if (isSetValue) {
                            val -= conf.min;
                        }

                        &#x2F;&#x2F; increment in steps
                        if (step) {
                            val = Math.round(val &#x2F; step) * step;
                        }

                        &#x2F;&#x2F; count x based on value or tweak x if stepping is done
                        if (x === undefined || step) {
                            x = val * len &#x2F; range;
                        }

                        &#x2F;&#x2F; crazy value?
                        if (isNaN(val)) {
                            return self;
                        }

                        &#x2F;&#x2F; stay within range
                        x = Math.max(0, Math.min(x, len));
                        val = x &#x2F; len * range;

                        if (isSetValue || !vertical) {
                            val += conf.min;
                        }

                        &#x2F;&#x2F; in vertical ranges value rises upwards
                        if (vertical) {
                            if (isSetValue) {
                                x = len - x;
                            } else {
                                val = conf.max - val;
                            }
                        }

                        &#x2F;&#x2F; precision
                        val = round(val, precision);

                        &#x2F;&#x2F; onSlide
                        var isClick = evt.type == &quot;click&quot;;
                        if (fireOnSlide &amp;&amp; value !== undefined &amp;&amp; !isClick) {
                            evt.type = &quot;onSlide&quot;;
                            fire.trigger(evt, [val, x]);
                            if (evt.isDefaultPrevented()) {
                                return self;
                            }
                        }

                        &#x2F;&#x2F; speed &amp; callback
                        &#x2F;&#x2F; 터치 거리에 따른 가속도값 필요
                        var speed = isClick ? conf.speed : 0,
                            callback = isClick ? function () {
                                evt.type = &quot;change&quot;;
                                fire.trigger(evt, [val]);
                            } : null;

                        if (vertical) {
                            this.progressHeight = len - x + handle.height() &#x2F; 2;
                            if ($.browser.os === &quot;IOS&quot; &amp;&amp; $.browser.version &gt; 4) {
                                handle.animate({
                                    top:x
                                }, speed, callback);
                            } else {
                                handle.transition({
                                    y:x
                                }, speed, callback);
                            }
                            if (false &amp;&amp; conf.progress) {
                                progress.css({
                                    height:this.progressHeight
                                });
                            }
                        } else {
                            this.progressWidth = x + handle.width() &#x2F; 2;
                            if ($.browser.os === &quot;IOS&quot; &amp;&amp; $.browser.version &gt; 4) {
                                handle.animate({
                                    left:x
                                }, speed, callback);
                            } else {
                                handle.css({
                                    transform: &quot;translate3d(0,0,0)&quot;
                                }).transition({
                                    x:x
                                }, speed, callback);
                            }
                            if (conf.progress) {
                                progress.css({
                                    transform:&quot;scale(1,1)&quot;
                                });
                            }
                        }

                        &#x2F;&#x2F; 현재값과 좌표 저장
                        value = val;
                        pos = x;

                        if(!this.insertingValue &amp;&amp; input[0].value != val) {
                            this.insertingValue = true;
                            input[0].value = val;
                            this.insertingValue = false;
                        }

                        return self;
                    }


                    $.extend(self, {

                        getValue:function () {
                            return value;
                        },

                        setValue:function (val, e) {
                            init();
                            return slide(e || $.Event(&quot;api&quot;), undefined, val, true);
                        },

                        getConf:function () {
                            return conf;
                        },

                        getProgress:function () {
                            return progress;
                        },

                        getHandle:function () {
                            return handle;
                        },

                        getInput:function () {
                            return input;
                        },

                        step:function (am, e) {
                            e = e || $.Event();
                            var step = conf.step == &#x27;any&#x27; ? 1 : conf.step;
                            self.setValue(value + step * (am || 1), e);
                        },

                        &#x2F;&#x2F; HTML5 compatible name
                        stepUp:function (am) {
                            return self.step(am || 1);
                        },

                        &#x2F;&#x2F; HTML5 compatible name
                        stepDown:function (am) {
                            return self.step(-am || -1);
                        }

                    });

                    &#x2F;&#x2F; callbacks
                    $.each(&quot;onSlide,change&quot;.split(&quot;,&quot;), function (i, name) {

                        &#x2F;&#x2F; from configuration
                        if ($.isFunction(conf[name])) {
                            $(self).on(name, conf[name]);
                        }

                        &#x2F;&#x2F; API methods
                        self[name] = function (fn) {
                            if (fn) {
                                $(self).on(name, fn);
                            }
                            return self;
                        };
                    });


                    &#x2F;&#x2F; dragging
                    handle.drag({drag:false}).on(&quot;dragStart&quot;,function () {

                        &#x2F;* do some pre- calculations for seek() function. improves performance *&#x2F;
                        init();

                        &#x2F;&#x2F; avoid redundant event triggering (= heavy stuff)
                        fireOnSlide = hasEvent($(self)) || hasEvent(input);


                    }).on(&quot;drag&quot;,function (e, y, x) {

                            if (input.is(&quot;:disabled&quot;)) {
                                return false;
                            }
                            slide(e, vertical ? y : x);

                        }).on(&quot;dragEnd&quot;,function (e) {
                            if (!e.isDefaultPrevented()) {
                                e.type = &quot;change&quot;;
                                fire.trigger(e, [value]);
                            }

                        }).click(function (e) {
                            return e.preventDefault();
                        });

                    &#x2F;&#x2F; clicking
                    root.click(function (e) {
                        if (input.is(&quot;:disabled&quot;) || e.target == handle[0]) {
                            return e.preventDefault();
                        }
                        init();
                        var fix = vertical ? handle.height() &#x2F; 2 : handle.width() &#x2F; 2;
                        slide(e, vertical ? len - origo - fix + e.pageY : e.pageX - origo - fix);
                    });

                    if (conf.keyboard) {

                        input.keydown(function (e) {

                            if (input.attr(&quot;readonly&quot;)) {
                                return;
                            }

                            var key = e.keyCode,
                                up = $([75, 76, 38, 33, 39]).index(key) != -1,
                                down = $([74, 72, 40, 34, 37]).index(key) != -1;

                            if ((up || down) &amp;&amp; !(e.shiftKey || e.altKey || e.ctrlKey)) {

                                &#x2F;&#x2F; UP: 	k=75, l=76, up=38, pageup=33, right=39
                                if (up) {
                                    self.step(key == 33 ? 10 : 1, e);

                                    &#x2F;&#x2F; DOWN:	j=74, h=72, down=40, pagedown=34, left=37
                                } else if (down) {
                                    self.step(key == 34 ? -10 : -1, e);
                                }
                                return e.preventDefault();
                            }
                        });
                    }


                    input.blur(function (e) {
                        var val = $(this).val();
                        if (val !== value) {
                            self.setValue(val, e);
                        }
                    });


                    &#x2F;&#x2F; HTML5 DOM methods
                    $.extend(input[0], { stepUp:self.stepUp, stepDown:self.stepDown});


                    &#x2F;&#x2F; calculate all dimension related stuff
                    function init() {
                        vertical = conf.vertical || dim(root, &quot;height&quot;) &gt; dim(root, &quot;width&quot;);

                        if (vertical) {
                            len = dim(root, &quot;height&quot;) - dim(handle, &quot;height&quot;);
                            origo = root.offset().top + len;

                        } else {
                            len = dim(root, &quot;width&quot;) - dim(handle, &quot;width&quot;);
                            origo = root.offset().left;
                        }
                    }

                    function begin() {
                        init();
                        self.setValue(conf.value !== undefined ? conf.value : conf.min);
                    }

                    begin();

                    &#x2F;&#x2F; some browsers cannot get dimensions upon initialization
                    if (!len) {
                        $(window).load(begin);
                    }
                }

                $.expr[&#x27;:&#x27;].range = function (el) {
                    var type = el.getAttribute(&quot;type&quot;);
                    return type &amp;&amp; type == &#x27;range&#x27; || !!$(el).filter(&quot;input&quot;).data(&quot;rangeinput&quot;);
                };

                &#x2F;&#x2F; jQuery plugin implementation
                $.fn._rangeinput = function (conf) {

                    &#x2F;&#x2F; already installed
                    if (this.data(&quot;rangeinput&quot;)) {
                        return this;
                    }

                    &#x2F;&#x2F; extend configuration with globals
                    conf = $.extend(true, {}, defaultOptions, conf);

                    var els;

                    this.each(function () {
                        var el = new RangeInput($(this), $.extend(true, {}, conf));
                        var input = el.getInput().data(&quot;rangeinput&quot;, el);
                        els = els ? els.add(input) : input;
                    });

                    return els ? els : this;
                };

                this.$element._rangeinput(this.options);
            }
        };

        var widget = new Widget();
        widget.init();
    }(jQuery, this));
}));

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
