<h1>애플리케이션 작성법</h1>

<hr>

<h2>Web을 구성하는 세 가지 요소</h2>

<p>웹 페이지는 HTML, CSS, Javascript로 구성되며, 각각의 역할은 명확하게 구분되어 있다. HTML은 페이지의 내용을 기술하며, CSS는 페이지의 모양을 기술한다. Javascript는 사용자의 입력을 받아서 처리하고 결과를 만들어내는 기능을 수행한다.</p>

<h2>파일 나누기</h2>

<p>한 파일에 HTML, CSS, Javascript를 모두 기술할 수도 있지만 다음과 같은 이유로 각각은 별도의 파일로 작성하는 것을 권장한다.</p>

<ul>
<li>코드가 통합되어 있으면 프로젝트가 커지고 복잡해질 수록 관리하기 어렵다.</li>
<li>역할이 다른 코드는 따로 분리해야 코드가 간결해지고 이해하기 쉽다.</li>
<li>파일이 분리되어 있으면 여러 사람이 나누어서 작업하기 쉽다.</li>
<li>재사용성이 높아져 불필요한 반복을 하지 않게 된다.</li>
</ul>

<h2>디렉토리 구조</h2>

<p>파일을 분류하는 기준에는 여러 가지가 있을 수 있으며, 애플리케이션에 가장 맞는 방법을 선택하는 것이 좋다.
일반적인 경우에는 다음과 같은 구조를 권장한다.</p>

<pre><code>-+-- cornerstone
 +-- lib
 +-- style --+-- image
 +-- script -+-- model
 |           +-- view
 +-- template
</code></pre>

<p>각 디렉토리는 다음과 같은 용도로 사용한다.</p>

<ul>
<li>/ : html 파일을 넣어둔다. Single-page Web App이라면 html 파일은 하나면 충분하고, 페이지가 여러개로 구성되어 있다면 페이지 수만큼 html 파일이 존재할 것이며 페이지가 많아지면 하위 디렉토리를 만들어 구조화한다.</li>
<li>cornerstone : Framework 파일들을 넣어둔다.</li>
<li>lib : 애플리케이션에서 필요로 하는 외부 라이브러리들을 넣어둔다.</li>
<li>style : css 파일들을 넣어둔다. css 파일이 많아진다면 하위 디렉토리를 만들어 구조화한다.</li>
<li>style/image : css에서 사용하는 이미지 파일들을 넣어둔다.</li>
<li>script : 애플리케이션 메인 js 파일을 넣어둔다.</li>
<li>script/model : Model에 해당하는 js 파일을 넣어둔다. Model이 많아진다면 하위 디렉토리를 만들어 구조화한다.</li>
<li>script/view : View에 해당하는 js 파일을 넣어둔다. View가 많아진다면 하위 디렉토리를 만들어 구조화한다.</li>
<li>template : template 파일들을 넣어둔다. 파일이 많아진다면 하위 디렉토리를 만들어 구조화한다.</li>
</ul>

<p><code>애플리케이션 메인, Model, View, Template에 대해서는 다음에 다시 설명하니 당장 이해가 안되더라도 넘어가도록 하자.</code></p>

<h2>Single-page Web App</h2>

<p>Single-page Web App은 하나의 페이지로 이루어진 웹 애플리케이션을 말한다. 페이지가 하나이므로 다른 페이지로 이동하거나 페이지 전체를 갱신하는 일 없이, 높은 사용성과 빠른 속도를 제공한다.</p>

<p>하지만, 하나의 페이지에 과도하게 많은 기능이 들어가면 페이지의 초기 로딩 시간이 길어지고 많은 메모리를 사용하게 되므로 적절하게 여러 페이지로 나누어 주는 것도 중요하다. 여러 개의 페이지로 구성할 경우 페이지가 전환될 때 메모리가 초기화되고 html, css, js들을 다시 로드해야 하므로 연관성이 깊은 기능들끼리 같은 페이지로 묶는 것이 중요하다.</p>

<h2>자바스크립트 모듈화</h2>

<p>애플리케이션이 많은 기능을 가질 수록 자바스크립트의 양이 많아지고 복잡해지는 것은 필연적이다. 자바스크립트를 역할과 용도에 따라 분할해서 관리해야 재사용성과 유지보수성이 높아지는 것은 당연하다. 이렇게 분할된 여러 개의 js 파일을 script 태그를 사용해서 일일이 로드하는 것도 한 방법이나 다음과 같은 문제점을 가지게 된다.</p>

<ul>
<li>개발자가 사용하고자 하는 js 파일을 a.js라고 하고, a.js가 내부적으로 b.js를 사용하고 있다고 하면, 개발자는 a.js 만을 필요로 하더라도 b.js도 로드해야 한다. 개발자가 사용하고자 하는 js 파일간의 의존성을 모두 파악하고 있어야 한다.</li>
<li>b.js를 먼저 로드하고, a.js를 로드해야 한다. script 태그를 작성하는 순서를 항상 고려해야 한다.</li>
<li>기본적으로 브라우저는 스크립트를 동기적으로 로드하기 때문에(하나씩 순서대로) js 파일이 많아지는 경우 필요 이상의 시간이 소요되며, 그 문제를 해결하기 위해 async 속성을 선택적으로 부여하는 것은 막노동에 가까운 일이 된다.</li>
</ul>

<p>이 문제를 해결하기 위해 Cornerstone Framework는 require.js를 사용하여 자바스크립트 모듈화를 지원한다. require.js에 대해 자세히 알고 싶다면 <a href="http://requirejs.org">http://requirejs.org</a> 를 방문하기 바란다.</p>

<p>require.js를 사용하면 하나의 js 파일을 하나의 모듈로서 정의할 수 있고, 모듈간의 의존성을 명시할 수 있다. 개발자는 필요한 모듈 하나만 선택해서 사용하면 된다. require.js가 선택된 모듈과 의존성을 가지는 모듈을 모두 알아서 순서에 맞게 로드하고 가능한 한 병렬적으로 로드하기 때문에 시간이 필요 이상으로 소요되는 문제도 해결된다.</p>

<p>하나의 파일에서는 하나의 모듈만 정의할 수 있으며, 다음과 같이 define 함수로 모듈을 정의할 수 있다.</p>

<pre><code>// model/user.js 파일에서 정의한 모듈
define( {
    name: &#39;홍길동&#39;,
    age: 40,
    gender: &#39;남&#39;
} );
</code></pre>

<p>정의된 모듈을 사용하는 쪽에서는 require 함수를 사용한다.</p>

<pre><code>require( [ &#39;model/user&#39; ], function( user ) {
    // 40이 콘솔로 출력된다.
    console.log( user.age );
} );
</code></pre>

<p>require 함수의 첫번째 파라미터는 필요한 모듈명의 배열이다. 모듈명은 js 파일의 상대 경로명에서 확장자를 제외한 것이다. 두번째 파라미터는 필요한 모듈이 모두 다 로드되고 나면 실행되는 함수인데, 함수의 파라미터로 로드된 모듈들이 넘겨진다.</p>

<p>모듈을 정의할 때 모듈이 정적인 object가 아니라 매번 새로운 객체를 사용해야 한다면, define 함수를 사용할 때 object 대신 function을 사용한다.</p>

<pre><code>define( function() {

    // 나이를 매번 계산
    var age = …;

    return {
        name: &#39;홍길동&#39;,
        age: age,
        gender: &#39;남&#39;
    };
} );
</code></pre>

<p>정의하고자 하는 모듈이 다른 모듈을 사용해야 한다면, require 함수를 사용할 때와 같은 방식으로 사용 가능하다.</p>

<pre><code>define( [ &#39;model/calculator&#39; ], function( calculator ) {

    // 나이를 매번 계산
    var age = calculator.calculateAge();

    return {
        name: &#39;홍길동&#39;,
        age: age,
        gender: &#39;남&#39;
    };
} );
</code></pre>

<p>모든 js 파일들은 모듈로 정의되는 것이 좋다.</p>

<h2>HTML 만들기</h2>

<p>각 html 파일은 다음과 같이 작성된다.</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;ko&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;/&gt;
        &lt;title&gt;Sample App&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&quot;container&quot;&gt;
        (중략)
        &lt;/div&gt;
        &lt;script src=&quot;cornerstone/launcher.js&quot; data-target=&quot;script/main&quot;&gt;&lt;/script&gt; 
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>body 태그 내에 내용을 작성하고 가장 마지막에 script 태그를 사용함을 주목하자. 이렇게 하면 스크립트가 로딩이 되기 전에 페이지 렌더링을 시작하므로 화면이 더 빨리 뜨는 효과를 기대할 수 있다.</p>

<p>cornerstone/launcher.js는 애플리케이션을 실행시켜주는 스크립트이다. script 태그의 data-target 속성에 애플리케이션 메인의 모듈명을 지정한다.</p>

<p>작성해야 할 script 태그는 하나 뿐이다. 앞으로는 스크립트와 스타일시트를 로드하기 위해 link, script 태그를 직접 작성하지 않고, Framework에서 제공하는 기능을 사용하여 로드하도록 한다.</p>

<h2>애플리케이션 메인</h2>

<p>애플리케이션 메인은 페이지가 뜨고 가장 먼저 실행되는 애플리케이션의 자바스크립트 코드를 의미한다. 메인의 위치가 앞으로 다른 모듈들을 로드하는데 사용하는 경로의 기준 위치(BaseUrl)가 된다.</p>

<blockquote>
<p>메인의 위치가 script 디렉토리이고 이 위치가 기준 위치가 되기 때문에 &#39;model/user&#39; 모듈명은 &#39;script/model/user.js&#39; 파일과 매핑된다.</p>
</blockquote>

<p>다른 js 파일들과 마찬가지로 애플리케이션 메인 역시 require.js의 모듈로 정의되어야 한다. 다만 다른 모듈과 다른 점은 애플리케이션 메인 모듈에는 launch 함수가 반드시 존재해야 한다. cornerstone/launcher.js가 Framework을 초기화하고 모든 준비가 완료되면 애플리케이션 메인의 launch 함수를 실행시켜준다.</p>

<pre><code>define( function() {
    return {
        launch: function() {
            // 애플리케이션의 시작점
        }
    };
} );
</code></pre>

<h2>Require.js 설정</h2>

<p>Cornerstone Framework은 기본적으로 많은 Open Source 라이브러리들을 내장하고 있으며, 그 라이브러리들도 모듈화되어 있기 때문에 모듈을 사용하는 것처럼 라이브러리를 사용할 수 있다. 기본적으로 제공하는 모듈은 다음과 같다.</p>

<table><thead>
<tr>
<th align="left">모듈명</th>
<th align="left">설명</th>
</tr>
</thead><tbody>
<tr>
<td align="left">jquery</td>
<td align="left"><a href="http://jquery.com">jQuery core 라이브러리</a></td>
</tr>
<tr>
<td align="left">underscore</td>
<td align="left"><a href="http://underscorejs.org/">Underscore</a></td>
</tr>
<tr>
<td align="left">backbone</td>
<td align="left"><a href="http://backbonejs.org/">Backbone</a></td>
</tr>
</tbody></table>

<p><strong><code>추가 명시 필요</code></strong></p>

<p>기본적으로 제공하는 모듈 외에 추가해서 사용하는 라이브러리가 있다면 다음과 같은 설정을 통해서 모듈화할 수 있다.
설정 코드는 애플리케이션 메인의 define 앞쪽에 작성할 것을 권장한다.</p>

<pre><code>requirejs.config( {
    // 긴 경로명을 짧게 줄여서 모듈명으로 사용할 수 있다.
    paths: {
        &#39;libname&#39;: &#39;../lib/somelibrary-1.0.0-min&#39;
    },
    // 모듈의 의존성과 내용을 지정한다.
    shim: {
        &#39;libname&#39;: {
            // 이 모듈은 jquery, underscore를 사용하기 때문에 jquery, underscore를 먼저 로드한다.
            deps: [ &#39;jquery&#39;, &#39;underscore&#39; ],
            exports: function() {
                // require/define에서 이 모듈을 사용할 때 파라미터로 전달되는 내용
                // 여기서 this는 브라우저의 window 객체이다.
                return this.Somelibrary.noConflict();
            }
        }
    }
} );
</code></pre>

<h2>MVC 패턴</h2>

<p>MVC(Model-View-Controller) 패턴은 애플리케이션을 Model, View, Controller로 분리해서 작성하는 패턴이다. 이런식으로 애플리케이션을 작성하면 사용자 인터페이스와 비즈니스 로직을 분리해서 서로 영향을 주지 않도록 작성할 수 있고 이는 비즈니스 로직 및 데이터의 재사용성을 높여준다. 각 요소는 다음과 같은 역할을 가진다.</p>

<ul>
<li>Model : 애플리케이션의 데이터 및 데이터와 관련된 로직을 관리한다.</li>
<li>View : Model을 표현하는 방식을 결정하고 사용자 인터페이스를 담당한다.</li>
<li>Controller : 사용자의 입력을 전달받아 처리하고, Model과 View에 명령을 내린다.</li>
</ul>

<p>이 패턴을 그림으로 나타내면 다음과 같다.</p>

<p><img src="images/mvc.png?raw=true" alt=""></p>

<p><code>이미지 출처: http://blog.nodejitsu.com/scaling-isomorphic-javascript-code</code></p>

<p>Cornerstone Framework은 MVC 패턴을 지원하기 위해 Backbone을 포함하고 있다. Backbone에 대해서 더 자세히 알고 싶으면 <a href="http://backbonejs.org">http://backbonejs.org</a> 를 방문하기 바란다.</p>

<p>Backbone에서 사용하는 MVC 패턴은 전통적인 MVC 패턴과 조금 차이가 있는데, 아래 그림을 보면 잘 알 수 있다.</p>

<p><img src="images/backbone-mvc.png?raw=true" alt=""></p>

<p><code>이미지 출처: http://blog.nodejitsu.com/scaling-isomorphic-javascript-code</code></p>

<p>전통적인 MVC 패턴은 Controller가 Model을 조작하도록 되어 있지만, Backbone은 View가 직접 Model을 조작하는 것을 권장하고 있다. 이렇게 되면 Controller의 역할 중 상당 부분을 View가 가져가는 것이기 때문에 Controller가 가벼워지고 View가 무거워진다. 이것은 Model-View-Controller가 서로 균형을 이루는 이상적인 MVC 패턴은 아닐 수 있지만, 사용자의 입력을 View가 받아서 Controller로 전달하는 비효율을 제거해 코드의 양을 줄이고 성능을 향상시킬 수 있다. </p>

<h2>Model 만들기</h2>

<p>다음과 같이 Backbone.Model의 extend를 사용하면 자신만의 Model 클래스를 정의하고 클래스의 인스턴스를 생성할 수 있다. defaults는 객체를 생성할 때 사용할 기본 속성값들을 의미하고, initialize는 객체가 생성되면 실행되는 생성자 함수이다.</p>

<pre><code>var User = Backbone.Model.extend( {

    defaults: {
        name: &#39;홍길동&#39;,
        age: 40
    },

    initialize: function() {
        // Model이 생성되면 실행된다.
        console.log( &#39;Created!&#39; );
    }
} );

var user = new User();
</code></pre>

<p>Backbone 역시 require.js 모듈로 제공되므로 전체 코드는 다음처럼 될 것이다.</p>

<pre><code>// model/user
define( [ &#39;backbone&#39; ], function( Backbone ) {

    return Backbone.Model.extend( {

        defaults: {
            name: &#39;홍길동&#39;,
            age: 40
        },

        initialize: function() {
            // Model이 생성되면 실행된다.
            console.log( &#39;Created!&#39; );
        }
    } );
} );
</code></pre>

<pre><code>require( [ &#39;model/user&#39; ], function( User ) {
    var user = new User();
} );
</code></pre>

<p>Model 객체를 생성할 때 속성값들을 지정할 수 있고, get 메소드를 사용해 각각의 속성값을 구할 수 있다.</p>

<pre><code>var user = new User( { name: &#39;김철수&#39; } );

console.log( user.get( &#39;name&#39; ) );    // 콘솔에 &#39;김철수&#39; 출력
console.log( user.get( &#39;age&#39; ) );    // 콘솔에 &#39;40&#39; 출력
</code></pre>

<p>set 메소드를 사용하면 속성값을 변경할 수 있다.</p>

<pre><code>user.set( &#39;name&#39;, &#39;박영수&#39; );
user.set( { name: &#39;박영수&#39;, age: 35 } );    // 여러 값을 한번에 변경 가능하다.
user.set( &#39;job&#39;, &#39;컨설턴트&#39; );    // 새로운 값을 지정할 수도 있다.
</code></pre>

<p>속성값이 변경되면 Model 객체에서 change 이벤트가 발생한다. on 또는 bind 메소드를 사용하면 이벤트가 발생했을 때 실행될 callback 함수를 지정할 수 있다. off 또는 unbind 메소드를 사용하면 지정된 callback 함수를 제거할 수 있다.</p>

<pre><code>user.on( &#39;change&#39;, function() {
    // 아무 속성값이나 변경되면 실행된다.
} );

user.on( &#39;change:name&#39;, function() {
    // name 속성의 값이 변경되면 실행된다.
} );

// change 이벤트의 모든 callback을 제거한다.
user.off( &#39;change&#39; );
</code></pre>

<p>Model의 고유한 식별자는 cid와 id의 두가지가 있다. cid는 Client ID라는 의미로 Model 객체가 생성될 때 자동으로 부여되는 식별자이고, id는 개발자가 직접 부여해 주는 식별자이다. 일반적으로 클라이언트에서 생성된 Model 객체는 일단 cid만을 가지게 되고 Model의 데이터가 서버에 저장이 되고 나면 데이터베이스에 저장할 때 만들어지는 Primary Key 값으로 Model의 id를 업데이트한다. 혹은 서버와 연동하지 않고 브라우저의 로컬 스토리지를 사용한다면 로컬 스토리지에 저장하면서 id를 부여할 수도 있다.</p>

<pre><code>// 새로 만들어진 Model인지 검사한다.
if ( user.isNew() ) {
}
</code></pre>

<p>isNew 메소드는 Model이 새로 만들어진 것인지를 검사하는데, 새로 만들어진 Model 이라는 의미는 아직 서버에 저장되지 않았음을 의미한다. 그리고, id가 없으면 서버에 저장되지 않은 것으로 간주한다. 이것은 바꿔 말하면 Model을 서버에 저장한 후에는 반드시 id를 부여해야 함을 의미한다.</p>

<h2>Collection 만들기</h2>

<p>Collection은 Model의 정렬된 집합이다. Collection에 담겨 있는 Model의 속성이 변경되면 해당 Model 뿐 아니라 Collection에도 change 이벤트가 발생한다. Collection에 Model이 추가되거나 삭제되면 add, remove 이벤트가 발생한다.</p>

<p>자신만의 Collection 클래스를 정의하고 인스턴스를 생성하고 싶다면 extend 메소드를 사용한다.</p>

<pre><code>var Users = Backbone.Collection.extend( {
    model: User
} );

// 빈 Collection 객체 생성
var users1 = new Users();

// Model들을 추가해서 Collection을 생성
var users2 = new Users( [ user1, user2, user3 ] );

// 객체를 추가해서 Collection을 생성, 각 객체는 User Model로 변환되서 추가된다.
var users3 = new Users( [
    { name: &#39;홍길동&#39;, age: 40 },
    { name: &#39;김철수&#39;, age: 35 },
    { name: &#39;이영수&#39;, age: 20 }
] );
</code></pre>

<p>Collection 객체를 생성한 후에 Model을 추가하고, 여러 가지 방법으로 Model을 찾을 수 있다. Colelction 내에서 Model들은 추가한 순서대로 유지된다.</p>

<pre><code>users1.add( [
    { name: &#39;박철수&#39;, age: 25 },
    { name: &#39;최영희&#39;, age: 30 }
] );

// id로 Model을 찾는다. 
var user1 = users1.get( 35 );

// cid로 Model을 찾는다.
var user2 = users1.getByCid( &#39;c6&#39; );

// 2번째 Model을 구한다.
var user3 = users1.at( 1 );

// age가 30인 Model들을 찾는다. (Model의 배열을 리턴한다.)
var users4 = users1.where( { age: 30 } );
</code></pre>

<h2>View 만들기</h2>

<p>View의 역할은 사용자와 상호작용하는 것이다. 즉, View는 Model을 어떤 방식으로 사용자에게 보여줄지를 결정하고, 사용자의 입력을 받아서 어떻게 반응할지를 결정한다. 따라서 View는 특정 Model과 연결되어서 Model의 값이 변경될때마다 화면을 다시 그려주는 작업과 사용자의 입력으로 인해서 발생하는 이벤트를 처리하는 작업을 해야 한다.</p>

<p>자신만의 View 클래스를 정의하고 인스턴스를 생성하는 방법은 앞서 보았던 Model, Collection과 동일하다.</p>

<pre><code>var UserView = Backbone.View.extend( {

    tagName: &#39;ul&#39;,
    className: &#39;user&#39;,

    render: function() {
        // View를 그리는 코드를 작성한다.
    }

} );

var userView = new UserView( { model: user } );
</code></pre>

<p>모든 View 객체는 DOM element를 가진다. 이 DOM element는 실제로 페이지에 존재할 수도 있고 아닐 수도 있다. 위의 예에서 userView 객체는 <code>&lt;ul class=&quot;user&quot;&gt;&lt;/ul&gt;</code> 에 해당하는 DOM element를 자동으로 생성해서 가지게 되지만 아직 페이지에 삽입하지 않았으므로 보여지지는 않는다. 만약에 tagName을 지정하지 않는다면 div 를 생성한다.</p>

<p>el 속성을 지정하게 되면 DOM element를 새로 만들지 않고 페이지에 존재하는 DOM element를 찾아서 사용한다. el 속성을 지정할 때는 jQuery의 selector를 사용한다.</p>

<pre><code>var UserView = Backbone.View.extend( {

    el: &#39;section#list-section&#39;,

    render: function() {
        // View를 그리는 코드를 작성한다.
    }
} );
</code></pre>

<p>이 DOM element는 el 또는 $el 속성을 사용해서 구할 수 있다.</p>

<pre><code>// userView의 DOM element를 구한다.
var e1 = userView.el;

// userView의 DOM element에 해당하는 jQuery 객체를 구한다.
var e2 = userView.$el;
</code></pre>

<p>실제로 View를 그리는 작업은 render 메소드에서 일어난다. render 메소드에서는 Model 객체를 사용해서 HTML을 생성한 후 this.el을 갱신하고, 메소드의 끝에서 this를 리턴해 주어야 한다. 이것은 체인 호출(chained call)을 가능하게 한다.</p>

<pre><code>var UserView = Backbone.View.extend( {

    tagName: &#39;ul&#39;,
    className: &#39;user&#39;,

    render: function() {
        this.$el.html( &#39;&lt;span&gt;&#39; + this.model.get( &#39;age&#39; ) + &#39;&lt;/span&gt;&#39; );
        return this;
    }
} );

var userView = new UserView( { model: user } );

// View 객체를 그린 후 DOM element를 페이지에 삽입한다.
$( &#39;#user-list&#39; ).append( userView.render().el );
</code></pre>

<p>위 예는 render 메소드의 동작 방식을 설명하기 위해 단순하게 작성된 것이며, 저렇게 HTML 코드가 render 함수 내에 하드코딩 되는 것은 권장하지 않는다. Model 객체의 값으로 HTML을 만들어내는 작업은 나중에 설명될 템플릿을 사용하게 될 것이다.</p>

<p>사용자의 이벤트를 처리하려면 다음과 같이 events 속성을 지정한다.</p>

<pre><code>var UserView = Backbone.View.extend( {

    el: &#39;section#list-section&#39;,

    events: {
        &#39;dblclick&#39;: &#39;open&#39;,
        &#39;click .item&#39;: &#39;select&#39;,
        &#39;mouseover .title .date&#39;: &#39;showTooltip&#39;
    },

    open: function() {
        // section#list-section을 더블클릭하면 실행된다.
    },

    select: function() {
        // section#list-section 하위의 .item을 클릭하면 실행된다.
    },

    showTooltip: function() {
        // section#list-section 하위의 .title 또는 .date 위에 마우스를 올리면 실행된다.
    }
} );
</code></pre>

<p>events 속성은 &#39;eventName selector&#39;: &#39;callback&#39; 의 형식으로 기술된다. selector를 지정하지 않으면 el(View의 DOM element)에서 발생하는 이벤트를 의미하게 된다. Backbone.View는 내부적으로 이벤트를 처리할 때 jQuery의 delegate를 사용하므로 브라우저에서 기본적으로 발생하는 이벤트 뿐 아니라 jQuery Plugin을 사용하여 추가적으로 정의된 이벤트도 이벤트 이름(eventName)에 지정할 수 있다.</p>

<h2>Gesture Event</h2>

<p>스마트폰이나 스마트패드 등 터치 기반의 기기를 사용할 때는, 터치와 관련된 다양한 이벤트를 처리해야 할 경우가 있다. 일반적으로 iOS, 안드로이드 기기의 브라우저에서는 다음 이벤트들을 추가로 지원한다.</p>

<table><thead>
<tr>
<th align="left">이벤트명</th>
<th align="left">설명</th>
</tr>
</thead><tbody>
<tr>
<td align="left">touchstart</td>
<td align="left">화면에 손이 닿으면 발생한다. 마우스 기반의 이벤트 중에서 mousedown과 유사하다.</td>
</tr>
<tr>
<td align="left">touchmove</td>
<td align="left">화면에 손이 닿은 상태에서 이동하면 발생한다. 마우스 기반의 이벤트 중에서 mousemove와 유사하다.</td>
</tr>
<tr>
<td align="left">touchend</td>
<td align="left">화면에서 손을 떼면 발생한다. 마우스 기반의 이벤트 중에서 mouseup과 유사하다.</td>
</tr>
<tr>
<td align="left">touchcancel</td>
<td align="left">화면에 손이 닿은 상태에서 전화가 오거나 하는 등의 일이 발생하면 시스템에 의해 터치가 취소되면서 발생한다.</td>
</tr>
</tbody></table>

<p>따라서 Backbone View의 events 속성을 다음과 같이 지정해서 이벤트를 처리할 수 있다.</p>

<pre><code>var TouchView = Backbone.View.extend( {

    el: &#39;section#touch-section&#39;,

    events: {
        &#39;touchstart&#39;: &#39;start&#39;,
        &#39;touchmove&#39;: &#39;move&#39;,
        &#39;touchend&#39;: &#39;end&#39;
    },

    start: function( event ) {
        // 사용자가 section#touch-section을 터치하기 시작하면 실행된다.
    },

    move: function( event ) {
        // 사용자가 손을 댄 상태로 이동하면 실행된다.
    },

    end: function( event ) {
        // 사용자가 손을 떼면 실행된다.
    }
} );
</code></pre>

<p>하지만, 실제로 고수준의 웹앱을 만들다 보면 단순히 손가락이 닿고 떨어지는 이벤트보다는 복잡한 이벤트가 필요할 것이다. 그래서 Cornerstone Framework에서는 터치 기반의 여러가지 제스처를 처리할 수 있는 기능을 제공한다.</p>

<p>제스처 이벤트를 처리하기 위해서는 Backbone.View 대신에 Gesture View를 extend 해서 View를 만들어야 한다. Gesture View는 <code>gesture-view</code>라는 이름의 모듈로 제공된다.</p>

<pre><code>require( [ &#39;gesture-view&#39; ], function( GestureView ) {

    …

    var TouchView = GestureView.extend( {

        el: &#39;section#gesture-section&#39;,

        events: {
            &#39;tap&#39;: &#39;select&#39;,
            &#39;doubletap&#39;: &#39;open&#39;,
            &#39;hold&#39;: &#39;menu&#39;
        },

        select: function( event ) {
            // 사용자가 section#gesture-section을 탭하면 실행된다.
        },

        open: function( event ) {
            // 사용자가 section#gesture-section을 연속 두번 탭하면 실행된다.
        },

        menu: function( event ) {
            // 사용자가 section#gesture-section을 길게 터치하면 실행된다.
        }
    } );

    …

} );
</code></pre>

<p>Gesture View를 사용해서 처리할 수 있는 추가적인 이벤트는 다음과 같다.</p>

<table><thead>
<tr>
<th align="left">이벤트명</th>
<th align="left">설명</th>
</tr>
</thead><tbody>
<tr>
<td align="left">tap</td>
<td align="left">화면을 두드리면 발생한다. 마우스 기반의 이벤트 중에서 click과 유사하다.</td>
</tr>
<tr>
<td align="left">doubletap</td>
<td align="left">화면을 빠르게 연속으로 두번 두드리면 발생한다. 마우스 기반의 이벤트 중에서 dblclick과 유사하다.</td>
</tr>
<tr>
<td align="left">hold</td>
<td align="left">화면에 일정 시간(0.5초) 이상 손을 대고 있으면 발생한다.</td>
</tr>
<tr>
<td align="left">dragstart</td>
<td align="left">화면을 잡아 끄는 작업이 시작하면 발생한다.</td>
</tr>
<tr>
<td align="left">drag</td>
<td align="left">화면을 잡아 끄는 동안 손가락이 이동할 때 마다 발생한다.</td>
</tr>
<tr>
<td align="left">dragend</td>
<td align="left">화면을 잡아 끄는 작업이 끝나면 발생한다.</td>
</tr>
<tr>
<td align="left">swipe</td>
<td align="left">화면을 특정 방향으로 쓸면 발생한다. drag의 특정 형태이며 일반적으로 다른 항목이나 화면으로 이동하려고 할 때 사용한다.</td>
</tr>
<tr>
<td align="left">transformstart</td>
<td align="left">두 손가락을 사용해서 오므리거나 벌리거나(pinch) 회전시키는 동작을 시작하면 발생한다.</td>
</tr>
<tr>
<td align="left">transform</td>
<td align="left">두 손가락을 사용해서 오므리거나 벌리거나 회전시키는 동작을 하는 동안 손가락이 이동할 때 마다 발생한다.</td>
</tr>
<tr>
<td align="left">transformend</td>
<td align="left">두 손가락을 사용해서 오므리거나 벌리거나 회전시키는 동작이 끝나면 발생한다.</td>
</tr>
<tr>
<td align="left">release</td>
<td align="left">화면에서 손이 떨어지면 발생한다.</td>
</tr>
</tbody></table>

<p>이벤트가 발생하면 자세한 정보를 담고 있는 event 객체가 callback의 인자로 전달된다. event 객체가 담고 있는 정보는 이벤트의 종류에 따라 다르지만 다음 속성들은 공통적으로 제공된다.</p>

<table><thead>
<tr>
<th align="left">속성명</th>
<th align="left">설명</th>
</tr>
</thead><tbody>
<tr>
<td align="left">originalEvent</td>
<td align="left">브라우저에 의해서 제공되는 DOM event 객체</td>
</tr>
<tr>
<td align="left">position</td>
<td align="left">제스처가 일어난 좌표. transition일 경우에는 두 손가락의 중간 위치의 좌표</td>
</tr>
<tr>
<td align="left">touches</td>
<td align="left">터치 정보의 배열, 여러 손가락을 동시에 터치할 때 각 터치의 정보를 제공한다.</td>
</tr>
</tbody></table>

<h3>drag, swipe 이벤트</h3>

<p>dragstart, drag, dragend, swipe 이벤트가 발생할 때 event 객체에는 다음 속성들이 추가로 제공된다.</p>

<table><thead>
<tr>
<th align="left">속성명</th>
<th align="left">설명</th>
</tr>
</thead><tbody>
<tr>
<td align="left">angle</td>
<td align="left">이동의 각도. 단위는 &#39;도&#39;이며 오른쪽이 0, 왼쪽이 -180, 위가 -90, 아래가 90이다.</td>
</tr>
<tr>
<td align="left">direction</td>
<td align="left">이동한 대략적인 방향을 간단한 문자열로 표현한다. up/right/down/left</td>
</tr>
<tr>
<td align="left">distance</td>
<td align="left">이동한 거리. 단위는 픽셀이다.</td>
</tr>
<tr>
<td align="left">distanceX</td>
<td align="left">X 축으로 이동한 거리. 단위는 픽셀이다.</td>
</tr>
<tr>
<td align="left">distanceY</td>
<td align="left">Y 축으로 이동한 거리. 단위는 픽셀이다.</td>
</tr>
</tbody></table>

<p>이동한 거리는 dragstart가 발생한 위치를 기준으로 해서 계산된다.</p>

<h3>transform 이벤트</h3>

<p>transformstart, transform, transformend 이벤트가 발생할 때 event 객체에는 다음 속성들이 추가로 제공된다.</p>

<table><thead>
<tr>
<th align="left">속성명</th>
<th align="left">설명</th>
</tr>
</thead><tbody>
<tr>
<td align="left">scale</td>
<td align="left">두 손가락간의 거리. 초기값을 1로 봤을 때의 배율을 의미한다. 즉, 두 손가락의 거리가 2배가 되도록 벌리면 2가 되고, 절반이 되도록 오므리면 0.5가 된다. 거리에 변화가 없으면 1이다.</td>
</tr>
<tr>
<td align="left">rotation</td>
<td align="left">회전한 각도. 단위는 &#39;도&#39;이며 두 손가락을 시계방향으로 회전하면 양수, 반시계방향으로 회전하면 음수가 된다. 회전하지 않았다면 0이다.</td>
</tr>
</tbody></table>

<p>거리와 각도 역시 transformstart가 발생한 위치를 기준으로 해서 계산된다.</p>

<h2>Template</h2>

<p>View의 render 함수를 구현하다 보면 많은 양의 HTML 코드가 들어가게 된다. 그리고, 정적인 HTML 마크업이 아니라 데이터에 따라 동적으로 변화되어야 할 부분이 많아지면 HTML 코드와 자바스크립트 코드가 뒤섞여 이해하기 힘든 복잡한 코드가 된다.</p>

<p>다음은 사용자의 정보를 표시하는 View의 한 예이다.</p>

<pre><code>var UserView = Backbone.View.extend( {

    …

    render: function() {

        var html = &#39;&lt;div class=&quot;user&quot;&gt;&#39; +
            &#39;&lt;span&gt;&#39; + this.model.get( &#39;name&#39; ) + &#39;&lt;/span&gt;&#39; +
            &#39;&lt;span&gt;&#39; + this.model.get( &#39;age&#39; ) + &#39;&lt;/span&gt;&#39;;

        // male이 true이면 남자, false이면 여자
        if ( this.model.get( &#39;male&#39; ) )
            html += &#39;&lt;span&gt;남자&lt;/span&gt;&#39;;
        else
            html += &#39;&lt;span&gt;여자&lt;/span&gt;&#39;;

        html += &#39;&lt;/div&gt;&#39;;

        this.$el.html( html );
        return this;
    }
} );
</code></pre>

<p>Template을 사용하면 HTML 코드와 조건에 따라 변화하는 부분을 별도로 분리할 수 있어, 이 복잡함을 해소할 수 있다.</p>

<p>Template은 확장자가 <code>.template</code>인 별도의 텍스트 파일로 만들어진다. 위의 render 함수의 내용을 Template으로 만들면 다음과 같다.</p>

<pre><code>&lt;div class=&quot;user&quot;&gt;
    &lt;span&gt;{{user.name}}&lt;/span&gt;
    &lt;span&gt;{{user.age}}&lt;/span&gt;
    &lt;span&gt;{{#if user.male}}남자{{else}}여자{{/if}}&lt;/span&gt;
&lt;/div&gt;
</code></pre>

<p>Template 내에서 조건이나 데이터에 따라서 변화되는 부분은 {{ 로 시작해서 }} 로 끝나는 블럭으로 표현된다. Cornerstone Framework은 Template을 해석하기 위해 내부적으로 Handlebars 라는 라이브러리를 이용한다. Template을 작성하는 방법에 대해 자세히 알고 싶다면 <a href="http://handlebarsjs.com">http://handlebarsjs.com</a> 를 방문하기 바란다.</p>

<p>만들어진 Template 파일도 js 파일과 마찬가지로 모듈로 사용할 수 있다. 단, 모듈 이름은 확장자를 생략한 형태이므로 모듈이 js 파일인지 Template 파일인지 구별하기 위해 Template 파일일 경우 모듈명 앞에 <code>template!</code>를 붙인다. 로드된 Template 모듈은 함수의 형태로 제공된다. 함수를 실행할 때 데이터를 인자로 넘기면 HTML 코드를 리턴한다. </p>

<pre><code>// tmpl/user.template 파일을 로드해서 userTemplate 함수의 형태로 제공한다.
require( [ &#39;template!tmpl/user&#39; ], function( userTemplate ) {

    var UserView = Backbone.View.extend( {

        …

        render: function() {
            this.$el.html( userTemplate( { user: this.model.toJSON() } ) );
            return this;
        }
    } );
} );
</code></pre>

<p>render 함수가 훨씬 간결하고 이해하기 쉽도록 향상되었다.</p>

<h2>스타일의 동적 로딩</h2>

<p>Template을 사용하게 되면 HTML 코드가 여러 파일로 분산된다. 그러다보면, 각 HTML 코드를 꾸며주는 css 코드 역시 여러 파일로 분산될 필요가 있을 것이다. 즉, Template 파일이 필요로 하는 css 파일들을 따로 분리해 놓았다면, 해당 Template을 사용하는 경우에만 로드되도록 할 수 있다.</p>

<p>css 파일도 js 파일과 Template 파일과 마찬가지로 모듈로 취급될 수 있다. 그러기 위해서는 Template을 사용할 때와 비슷하게 모듈명 앞에 <code>style!</code>을 붙여야 한다. css 모듈은 필요하다고(require) 선언이 되면 로드되어서 현재 페이지에 자동으로 적용된다. 따라서 모듈을 인자로 받아서 사용할 필요는 없다.</p>

<p>간단한 예로 위에서 사용한 <code>tmpl/user</code> Template에서 css/user.css 파일을 필요로 한다면 다음과 같은 식으로 사용할 수 있다.</p>

<pre><code>require( [ &#39;template!tmpl/user&#39;, &#39;style!css/user&#39; ], function( userTemplate ) {

    var UserView = Backbone.View.extend( {
        …
    } );
} );
</code></pre>

<p>위 방법은 직관적이고 이해하기 쉽지만 Template 모듈이 필요할 때 항상 css 모듈명도 같이 require에 선언해야 하는 불편함이 있다. Template 모듈만 require에 선언하면 자동으로 의존적인 css 모듈들이 모두 로드되도록 하고 싶다면 require.js 설정에 다음과 같이 의존성을 명시한다.</p>

<pre><code>requirejs.config( {
    shim: {
        &#39;template!tmpl/user&#39;: [ &#39;style!css/user&#39; ]
    }
} );
</code></pre>

<p>그러면 다음과 같이 Template만 선언해도 자동으로 css가 로드된다.</p>

<pre><code>require( [ &#39;template!tmpl/user&#39; ], function( userTemplate ) {

    var UserView = Backbone.View.extend( {
        …
    } );
} );
</code></pre>

<h2>Form View</h2>

<p>Form View는 Cornerstone Framework에서 제공하는 View 클래스 중의 하나로 Form의 데이터로 Model 객체를 만들고, 반대로 Model 객체의 값을 이용하여 Form의 값을 갱신해 주는 역할을 한다.</p>

<p>Form View는 <code>form-view</code>라는 이름의 모듈로 제공된다. 인스턴스를 생성할 때 form 태그를 나타내는 DOM element를 el 속성으로, Form과 연결될 Model 객체를 model 속성으로 지정한다.</p>

<pre><code>require( [ &#39;form-view&#39; ], function( FormView ) {

    ...

    var formView = new FormView( { el: &#39;#add-form&#39;, model: user } );
} );
</code></pre>

<p>Form View를 생성하면 지정된 Form과 Model 객체가 서로 밀접하게 연결된다. Model 객체의 값으로 Form이 자동으로 채워진다. Model 객체의 속성 이름과 Form의 하위 element의 name이 같은 것끼리 매칭된다. 이후에 Model 객체의 값을 변경하게 되면 자동으로 Form에 반영된다.</p>

<p>사용자가 Form에 값을 다 입력하고 submit 할 때, 다음과 같이 Form의 내용을 Model 객체에 반영하고 Model 객체를 구할 수 있다.</p>

<pre><code>function callbackOnSubmit() {

    var user = formView.toModel();

    // user 객체를 서버에 저장하는 등의 작업을 한다.
    …

    // 실제로 form의 submit이 일어나지 않게 한다.
    return false;
}
</code></pre>

<h2>Validation</h2>

<p>Model 객체에 값을 지정할 때, 특히 Form을 통해서 사용자가 입력한 내용을 Model 객체에 반영할 때, 잘못된 값을 입력하지는 않았는지 검증이 필요한 경우가 있다. Model 객체에 값을 지정할 때 유효성 검사를 하려면 Model에 validate 메소드를 추가하면 된다.</p>

<pre><code>var User = Backbone.Model.extend( {

    validate: function( atts ) {
        if ( !attrs.name )
            return { attribute: &#39;name&#39;, message: &#39;이름을 입력하세요.&#39; };
        if ( !attrs.name.length &gt; 50 )
            return { attribute: &#39;name&#39;, message: &#39;이름이 너무 깁니다.&#39; };
    }
} );
</code></pre>

<p>Model의 set 또는 save 메소드를 실행하면, 그 전에 validate 메소드가 자동으로 실행된다. validate에서 아무것도 리턴하지 않으면 모든 값이 유효한 것으로 간주해 set 또는 save 메소드를 실행하고, validate에서 오류를 리턴하면 error 이벤트를 발생시키고 set 또는 save 메소드는 실행되지 않는다.</p>

<p>validate에서 오류를 리턴할 때는, 오류 메시지를 나타내는 문자열만을 리턴해도 상관없지만 어느 속성에서 오류가 발생했는지를 알 수 있도록 하기 위해 <code>{ attribute: &#39;속성명&#39;, message: &#39;오류 메시지&#39; }</code> 형식의 객체를 리턴하는 것을 권장한다.</p>

<pre><code>// 유효성 검사가 실패하면 실행된다.
user.on( &#39;error&#39;, function( model, error ) {
    alert( error.attribute + &#39; 속성: &#39; + error.message );
} );
</code></pre>

<p>Form View의 toModel 메소드를 사용해서 Model 객체에 값을 지정할 때에도 동일한 매커니즘으로 동작한다. 다만, Form View는 Model의 유효성 검사가 실패했을 경우에 사용자에게 알려주는 코드를 기본적으로 내장하고 있기 때문에 error 이벤트에 대한 callback을 별도로 작성할 필요가 없다.</p>

<p>Form View를 사용할 때 Model의 유효성 검사가 실패했을 경우에 사용자에게 알려주는 코드는 Validation View라고 불리우며, 기본 Validation View가 Form View에 내장되어 있다. 사용자에게 알려주는 방식을 변경하고자 한다면 별도의 Validation View를 작성해서 Form View에 적용시킬 수도 있다.</p>

<p>다음은 기본 Validation View가 동작하는 방식을 설명하기 위한 Form의 예시이다. Bootstrap의 기본 Form 마크업대로 작성한 것이다.</p>

<pre><code>&lt;form id=&quot;add-form&quot; class=&quot;form-horizonal&quot;&gt;
    &lt;fieldset&gt;
        &lt;div class=&quot;control-group&quot;&gt;
            &lt;label class=&quot;control-label&quot; for=&quot;name&quot;&gt;이름&lt;/label&gt;
            &lt;div class=&quot;controls&quot;&gt;
                &lt;input type=&quot;text&quot; class=&quot;input-xlarge&quot; id=&quot;name&quot; name=&quot;name&quot;/&gt;
                &lt;span class=&quot;help-inline&quot;&gt;&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;control-group&quot;&gt;
            &lt;label class=&quot;control-label&quot; for=&quot;email&quot;&gt;이메일&lt;/label&gt;
            &lt;div class=&quot;controls&quot;&gt;
                &lt;input type=&quot;text&quot; class=&quot;input-xlarge&quot; id=&quot;email&quot; name=&quot;email&quot;/&gt;
                &lt;span class=&quot;help-inline&quot;&gt;&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/fieldset&gt;
&lt;/form&gt;
</code></pre>

<p>기본 Validation View는 다음과 같이 동작한다.</p>

<ol>
<li>error 이벤트에서 받은 error 객체에 attribute 속성이 있으면 해당 속성과 name이 일치하는 input을 찾는다.</li>
<li>attribute 속성이 없다면 form 내의 첫번째 input을 찾는다.</li>
<li>찾은 input이 속해 있는 control-group을 찾아 error 클래스를 추가한다.</li>
<li>control-group 내의 help-inline을 찾아서 내용에 오류 메시지를 업데이트한다.</li>
<li>help-inline이 없으면 input에 tooltip을 추가해서 오류 메시지를 표시한다.</li>
</ol>

<p>Bootstrap 기본 테마를 사용하고 있다면 아래와 같이 보일 것이다.</p>

<p><img src="images/validation1.png?raw=true" alt=""></p>

<p>만약에 input 다음에 있는 <code>&lt;span class=&quot;help-inline&quot;&gt;&lt;/span&gt;</code>을 제거한다면 tooltip이 자동적으로 추가되어 다음과 같이 보일 것이다.</p>

<p><img src="images/validation2.png?raw=true" alt=""></p>

<p>tooltip이 표시되는 위치가 마음에 들지 않는다면 아래와 같이 data-placement 속성을 추가해 tooltip이 표시되는 위치를 조정할 수 있다.</p>

<pre><code>&lt;input type=&quot;text&quot; class=&quot;input-xlarge&quot; id=&quot;name&quot; name=&quot;name&quot; data-placement=&quot;right&quot;/&gt;
</code></pre>

<p><img src="images/validation3.png?raw=true" alt=""></p>

<p>유효성 검사가 실패했을 때 오류 메시지를 다르게 표시하고 싶다면 새로운 Validation View를 만들어서 Form View의 기본 Validation View를 대체할 수 있다. Validation View는 다음과 같이 Backbone.View를 extend 해서 만든다.</p>

<pre><code>define( [ &#39;backbone&#39; ], function( Backbone ) {

    return Backbone.View.extend( {

        initialize: function() {
        },

        reset: function() {
        },

        success: function() {
        },

        fail: function( err ) {
        }
    } );
} );
</code></pre>

<p>위와 같이 4개의 메소드를 정의해야 하며, Validation View에서 el 속성은 속해 있는 Form View의 el 속성과 동일하다.</p>

<ol>
<li>initialize 메소드는 최초 한 번만 호출된다. 필요 없다면 생략해도 무방하다.</li>
<li>reset 메소드는 Validation View의 상태를 초기화해야 할 필요가 있을 때 호출된다. 유효성 검사를 하기 직전에 호출된다.</li>
<li>success 메소드는 유효성 검사가 성공했을 때 호출된다.</li>
<li>fail 메소드는 유효성 검사가 실패했을 때 호출된다. error 객체가 인자로 전달된다. error 객체는 Model의 validate 메소드에서 리턴하는 값이다. 따라서 validate 메소드를 어떻게 구현하느냐에 따라 error 객체의 형태는 달라진다.</li>
</ol>

<p>유효성 검사가 실패했을 때 alert 함수를 사용해서 오류 메시지를 보여주고 해당 input으로 포커스를 이동하고 싶다면 아래과 같이 Validation View를 만들 수 있다.</p>

<pre><code>define( [ &#39;backbone&#39;, &#39;jquery&#39; ], function( Backbone, $ ) {

    return Backbone.View.extend( {

        initialize: function() {
            this.reset();
        },

        reset: function() {
        },

        success: function() {
            this.reset();
        },

        fail: function( err ) {
            alert( err.message || err );
            if ( err.attribute ) this.$( &#39;:input[name=&#39; + err.attribute + &#39;]:first&#39; ).focus();
        }
    } );
} );
</code></pre>

<p>새로운 Validation View를 만들었으면 FormView를 생성할 때 다음과 같이 지정해서 사용할 수 있다.</p>

<pre><code>require( [ &#39;form-view&#39;, &#39;user-defined-validation-view&#39; ], function( FormView, UserDefinedValidationView ) {

    ...

    var formView = new FormView( { el: &#39;#add-form&#39;, model: user, validationViewClass: UserDefinedValidationView } );
} );

</code></pre>

<h2>동기화</h2>

<p>Model이나 Collection의 데이터는 메모리에 보관되므로 페이지가 다시 로드되기만 해도 데이터는 초기화된다. 따라서, 지속적으로 유지되는 공간에 데이터를 저장하고 읽어올 필요가 있다. Backbone.sync 가 그 작업에 도움이 될 것이다.</p>

<p>Backbone.sync는 Model의 fetch, save, destroy 함수와 Collection의 fetch 함수가 실행되면 해당 객체를 저장소와 동기화해 주는 함수이다. 이 함수는 기본적으로 HTTP 서버와 RESTful 하게 JSON 형식의 데이터를 주고 받도록 구현되어 있으며 다르게 동작하도록 재정의할 수도 있다.</p>

<h3>기본 동작</h3>

<p>Backbone.sync를 재정의하지 않고 기본 상태로 사용하면 HTTP 서버와 RESTful 하게 통신한다. 따라서, Collection과 각각의 Model은 고유한 URL을 가져야 하며 Collection의 URL은 다음과 같이 Collection 클래스를 정의하면서 지정할 수 있다.</p>

<pre><code>var Users = Backbone.Collection.extend( {
    url: &#39;/users&#39;
} );
</code></pre>

<p>또는 다음과 같이 Collection 객체를 생성하고 지정할 수도 있다.</p>

<pre><code>var users = new Users();
users.url = &#39;/users&#39;;
</code></pre>

<p>Collection에 속한 Model은 Collection의 url을 그대로 이어받는다. Collection의  url 뒤에 Model의 id를 덧붙인 것이 Model의 URL이 된다. Model의 url 메소드로 이 값을 구할 수 있다.</p>

<pre><code>var users = new Users();
var user1 = new User( { id: 1 } ), user2 = new User( { id: 2 } );
users.add( [ user1, user2 ] );

user1.url();    // 결과 값: /users/1
user2.url();    // 결과 값: /users/2
</code></pre>

<p>Collection에 속하지 않은 Model은 urlRoot 속성이 지정되어 있어야 url 메소드를 사용할 수 있다. Model의 urlRoot 속성은 Collection의 url과 동일한 역할을 하며 다음과 같이 지정하는 방법도 거의 동일하다.</p>

<pre><code>// Model 클래스를 정의하면서 지정하는 방법
var User = Backbone.Model.extend( {
    urlRoot: &#39;/users&#39;
} );

// Model 객체를 생성하면서 지정하는 방법
var user3 = new User();
user3.urlRoot = &#39;/users&#39;;
</code></pre>

<p>Collection 또는 Model의 url은 서버와 동기화할 때 주소로 사용된다. 위 예에서 사용된 <code>users</code> Collection 객체와 <code>user1</code> Model 객체의 fetch, save, destroy 메소드를 호출하면 다음과 같이 RESTful 한 HTTP 요청이 발생할 것이다.</p>

<table><thead>
<tr>
<th align="left">호출한 메소드</th>
<th align="center">HTTP Method</th>
<th align="left">URI</th>
</tr>
</thead><tbody>
<tr>
<td align="left">users.fetch()</td>
<td align="center">GET</td>
<td align="left">/users</td>
</tr>
<tr>
<td align="left">user1.fetch()</td>
<td align="center">GET</td>
<td align="left">/users/1</td>
</tr>
<tr>
<td align="left">id가 없을 경우 user1.save()</td>
<td align="center">POST</td>
<td align="left">/users</td>
</tr>
<tr>
<td align="left">id가 있을 경우 user1.save()</td>
<td align="center">PUT</td>
<td align="left">/users/1</td>
</tr>
<tr>
<td align="left">user1.destroy()</td>
<td align="center">DELETE</td>
<td align="left">/users/1</td>
</tr>
</tbody></table>

<p>데이터는 HTTP Body에 JSON 형식으로 들어간다.</p>

<h3>재정의</h3>

<p>동기화하는 방법을 변경하고 싶다면 Backbone.sync 함수를 다음과 같이 재정의하면 된다.</p>

<pre><code>Backbone.sync = function( method, model, options ) {
    // 중략
};
</code></pre>

<p>위 코드는 당연히 Collection이나 Model의 fetch, save, destroy 메소드가 호출되기 전에 실행되어야 한다.</p>

<p>함수는 3개의 인자를 받는데 의미는 다음과 같다.</p>

<ul>
<li>method : 동기화 작업의 종류 (create/read/update/delete)</li>
<li>model : 동기화 대상인 Model 객체 또는 Collection 객체</li>
<li>options : 성공, 실패했을 때 호출해야 하는 callback과 그 외 옵션들</li>
</ul>

<p>동기화와 관련된 편리한 기능들을 제공하기 위해 Cornerstone Framework에서는 <code>sync</code>라는 이름의 모듈을 제공한다.</p>

<p>일반적으로 함수 내에서 method 값에 따라서 분기해야 할 필요가 있을 것이다. 그 작업을 다음과 같이 좀 더 편하게 할 수 있다.</p>

<pre><code>require( [ &#39;backbone&#39;, &#39;sync&#39; ], function( Backbone, Sync ) {

    Backbone.sync = Sync.createSync( {

        // Collection.fetch가 실행되었을 때
        readAll: function( collection, options ) {
        },

        // Model.fetch가 실행되었을 때
        read: function( model, options ) {
        },

        // Model.save가 실행되었을 때 (새로 생성된 Model인 경우)
        create: function( model, options ) {
        },

        // Model.save가 실행되었을 때 (이미 존재하는 Model인 경우)
        update: function( model, options ) {
        },

        // Model.destroy가 실행되었을 때
        delete: function( model, options ) {
        }
    } );
} );
</code></pre>

<p>각 함수 내에서 동기화 작업이 성공했을 경우에는 <code>options.success</code> 함수를 실행시키고 실패했을 경우에는 <code>options.error</code> 함수를 실행시켜야 한다.</p>

<pre><code>var modelData = { id: 1, name: &#39;홍길동&#39; };

// 성공했을 경우
options.success( modelData );
// 실패했을 경우
options.error( &#39;데이터 조회 실패&#39; );
</code></pre>

<h3>로컬 스토리지와 동기화</h3>

<p>서버 없이 순수하게 브라우저에서만 동작하는 웹 앱이라면 로컬 스토리지와 동기화를 해야할 필요가 있다. 로컬 스토리지는 브라우저에서 관리하는 저장소이지만 페이지를 다시 로드해도 초기화되지 않고 계속 유지되는 저장소이다.</p>

<p>다음과 같은 간단한 코드로 로컬 스토리지와 동기화하도록 할 수 있다.</p>

<pre><code>require( [ &#39;backbone&#39;, &#39;sync&#39; ], function( Backbone, Sync ) {

    Backbone.sync = Sync.local;
} );
</code></pre>

<p>서버와 통신을 하지는 않지만 Collection과 Model을 내부적으로 분류하는 과정에서 url을 사용하기 때문에 로컬 스토리지와 동기화할 때도 URL은 지정하는 것이 좋다.</p>

<h2>Fragment와 라우팅</h2>

<p>여러 화면이 존재하는 Single-page Web App을 만든다고 가정해 보자. 다른 화면으로 이동할 때는 실제로 페이지를 전환하지 않고 AJAX를 사용해 페이지의 일부분을 다시 렌더링하게 될 것이다. 이 경우 실제로 페이지가 전환되는 것이 아니므로 현재 URL에는 변화가 없다. 즉, 각각의 화면은 고유한 URL을 가질 수 없고, 따라서 각 화면에 대한 하이퍼링크를 제공하거나 브라우저에 북마크로 등록하거나 하는 작업이 불가능해지며 브라우저의 Back/Forward 버튼을 사용해서 페이지 이동을 할 수도 없다. 이것은 웹으로서의 사용성을 해치는 일이기 때문에 해결책이 필요하다.</p>

<p>URL에 부가적인 정보를 더 담는 방법으로 Query가 있다. 웹 개발 경험이 있다면 누구나 한번쯤은 다음과 같이 물음표(?)를 사용하여 파라미터를 추가해 보았을 것이다.</p>

<pre><code>http://www.example.org/foo.html?bar=1
</code></pre>

<p>또 다른 방법으로는 Fragment가 있다. 이것은 Hash mark(#)를 사용하여 현재 페이지의 특정 위치를 가리킨다. Hash mark 뒷부분의 문자열을 Fragment identifier라고 한다.</p>

<pre><code>http://www.example.org/foo.html#bar
</code></pre>

<p>Query와 Fragment는 결정적인 차이점을 가지고 있는데, Query는 서버에서 처리되지만 Fragment는 클라이언트(웹 브라우저)에서 처리된다는 것이다. 즉, Fragment가 변경되어도 브라우저는 서버에 요청을 다시 보내지 않는다. 그래서 이점을 이용하여 Single-page Web App의 화면마다 다른 Fragment identifier를 부여하면, 결국 화면마다 고유한 URL을 가질 수 있게 되고 URL이 바뀌어도 페이지가 전환되지 않기 때문에 Single-page Web App을 유지할 수 있다.</p>

<blockquote>
<p>HTML5의 Push State를 사용하면 Fragment를 사용하지 않고도 이 문제를 해결할 수 있으나, Push State는 IE9 이하의 브라우저와 안드로이드의 기본 브라우저에서 제대로 지원하지 않으므로 사용하지 않는다.</p>
</blockquote>

<p>따라서 Fragment를 사용하면 애플리케이션에서는 페이지가 처음 실행되거나 Fragment identifier가 변경될 경우 그에 맞는 화면을 렌더링하는 작업을 해 주면 된다. 이를 간편하게 할 수 있도록 Backbone에서는 Router를 제공한다.</p>

<p>일반적으로 웹에서 라우팅은 URL에 패턴에 따라서 다른 모듈을 실행하도록 분기시키는 작업을 의미한다. Backbone의 Router는 Fragment identifier의 패턴에 따라서 지정된 함수를 실행하거나 이벤트를 발생시킨다.</p>

<pre><code>var MainRouter = Backbone.Router.extend( {

    // Fragment identifier의 패턴과 함수의 매핑
    routes: {
        &#39;&#39;: &#39;list&#39;,                // # or #이 없는 경우
        &#39;list&#39;: &#39;list&#39;,            // #list
        &#39;add&#39;: &#39;add&#39;,            // #add
        &#39;detail/:id&#39;, &#39;detail&#39;    // #detail/5
    },

    list: function() {
        // URL이 # 또는 #list로 끝나거나 #이 없는 경우 실행된다.
    },

    add: function() {
        // URL이 #add로 끝나면 실행된다.
    },

    detail: function( id ) {
        // URL 패턴에서 :로 시작되는 부분은 파라미터를 의미한다.
    }
} );

new MainRouter();

// Fragment identifier의 변경을 감지하고 라우팅을 처리한다.
Backbone.history.start();
</code></pre>

<p>위의 예에서 보는 것과 같이 동적으로 변화되는 부분은 :[변수명]의 형태로 쓰면 함수의 파라미터로 받을 수 있다.
라우팅 코드는 애플리케이션 메인의 launch 함수 내에 작성되는 것이 가장 적합하다.</p>

<h2>Multipage Router</h2>

<p>Backbone Router 만으로도 쉽게 라우팅을 처리할 수 있지만 웹 앱이 다음 조건을 만족한다면 Multipage Router를 사용해서 더 쉽게 페이지간 전환을 처리할 수 있다.</p>

<ol>
<li>하나의 HTML 문서 내에 여러 페이지가 존재하며 각각의 페이지가 block element(div, section 등)로 표현된다.</li>
<li>한 번에 하나의 페이지만 화면에 표시되고 나머지 페이지는 숨겨진다.</li>
<li>페이지마다 매핑되는 Fragment identifier가 존재해서, Fragment identifier가 변경되면 맞는 페이지가 표시되어야 한다.</li>
<li>페이지가 바뀔 때 애니메이션 효과가 필요하다.</li>
</ol>

<h3>마크업 작성</h3>

<p>페이지가 3개(목록, 추가, 상세정보)인 웹 앱을 만든다고 가정하자. 각각의 페이지를 block element로 표현해야 하므로, 다음과 같이 div를 3개 작성한다.</p>

<pre><code>&lt;div class=&quot;container&quot;&gt;
    &lt;div id=&quot;list&quot;&gt;&lt;/div&gt;
    &lt;div id=&quot;add&quot;&gt;&lt;/div&gt;
    &lt;div id=&quot;detail&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<h3>Router 작성</h3>

<p>Multipage Router는 <code>multipage-router</code>라는 이름의 모듈로 제공된다. Router를 extend 해서 정의한 후 객체를 생성하고 라우팅을 시작하는 코드까지 모두 Backbone의 Router와 사용법이 거의 동일하다.</p>

<pre><code>require( [ &#39;backbone&#39;, &#39;multipage-router&#39; ], function( Backbone, MultipageRouter ) {

    var MainRouter = MultipageRouter.extend( {
        // 중략
    } );

    new MainRouter();
    Backbone.history.start();
} );
</code></pre>

<p>Backbone의 Router에서는 routes 속성을 정의해서 Fragment identifier와 함수를 매핑했지만, MultipageRouter에서는 pages 속성과 transitions 속성을 정의한다. pages 속성에는 각 페이지의 정보와 상태에 따라 실행될 함수를 정의하고, transitions 속성에는 페이지 간 이동시에 적용될 애니메이션 효과를 정의한다.</p>

<p>앞서 Backbone.Router를 사용해서 작성했던 예를 MultipageRouter를 이용해서 바꿔보면 다음과 같다.</p>

<pre><code>var MainRouter = MultipageRouter.extend( {

    pages: {
        &#39;list-page&#39;: {
            fragment: [ &#39;&#39;, &#39;list&#39; ],
            el: &#39;div#list&#39;,
            active: &#39;list&#39;
        },
        &#39;add-page&#39;: {
            fragment: &#39;add&#39;,
            el: &#39;div#add&#39;,
            active: &#39;add&#39;
        },
        &#39;detail-page&#39;: {
            fragment: &#39;detail/:id&#39;,
            el: &#39;div#detail&#39;,
            active: &#39;detail&#39;
        }
    },

    list: function() {
        // URL이 # 또는 #list로 끝나거나 #이 없는 경우 실행된다.
    },

    add: function() {
        // URL이 #add로 끝나면 실행된다.
    },

    detail: function( id ) {
        // URL 패턴에서 :로 시작되는 부분은 파라미터를 의미한다.
    }
} );
</code></pre>

<p>routes 속성을 작성할 때 보다 내용이 길어졌지만, MultipageRouter는 훨씬 더 많은 작업을 수행한다. Backbone.Router는 단순히 Fragment identifer가 변경되는 이벤트를 감지할 뿐이지만, MultipageRouter는 그 외에도 Fragment identifier와 연결되어 있는 div만을 화면에 보여주고, 다른 div들은 자동으로 숨겨준다.</p>

<p>pages 속성 객체의 하위 속성들은 각각 하나의 페이지를 나타내고, 속성명(list-page, add-page, detail-page)은 페이지의 ID를 의미한다. 속성의 값은 다시 하위 속성들을 가지는데 그 의미는 다음과 같다.</p>

<ul>
<li>fragment : 해당 페이지를 활성화하는데 필요한 Fragment identifier의 패턴, 문자열로 하나를 지정하거나 배열로 여러 개를 지정할 수 있다.</li>
<li>el : 해당 페이지와 매핑되는 block element를 나타내는 jQuery selector</li>
<li>render : 해당 페이지가 활성화되고 Transition(화면 전환 애니메이션 효과)이 일어나기 전, 해당 페이지를 다시 렌더링하기 위해서 호출되는 callback 함수 또는 함수의 이름</li>
<li>active : 해당 페이지가 활성화되고 Transition이 완료되고 난 후에 호출되는 callback 함수 또는 함수의 이름</li>
<li>inactive : 다른 페이지가 활성화되면서 해당 페이지가 비활성화되면서 호출되는 callback 함수 또는 함수의 이름</li>
</ul>

<p>list-page에서 add-page로 이동한다고 가정했을 때 callback 함수가 실행되는 순서는 아래와 같다.</p>

<ol>
<li>list-page의 inactive 함수가 실행된다.</li>
<li>add-page의 render 함수가 실행된다.</li>
<li>화면 전환 애니메이션 효과가 발생한다.</li>
<li>add-page의 active 함수가 실행된다.</li>
</ol>

<p>Backbone.Router와는 달리 callback 함수의 이름 대신에 함수 자체를 지정할 수도 있다.</p>

<pre><code>&#39;list-page&#39;: {
    fragment: [ &#39;&#39;, &#39;list&#39; ],
    el: &#39;div#list&#39;,
    render: function() {
    },
    active: function() {
        // URL이 # 또는 #list로 끝나거나 #이 없는 경우 실행된다.
    }
}
</code></pre>

<p>기본 페이지를 설정하려면 페이지 ID를 default로 지정하면 된다. 기본 페이지는 Fragment identifier 패턴이 일치하는 페이지가 없을 경우에 매핑되는 페이지이다.</p>

<pre><code>&#39;default&#39;: {
    active: function( path ) {
        alert( &#39;존재하지 않는 주소입니다. : &#39; + path );
    }
}
</code></pre>

<h3>Transition 설정</h3>

<p>페이지 이동시에 애니메이션 효과를 주고 싶다면 transitions 속성을 지정하면 된다. transitions 속성 객체의 하위 속성명으로 &#39;이전 페이지 ID:다음 페이지 ID&#39; 를 주고, 속성 값으로는 Transition 종류를 지정한다.</p>

<pre><code>transitions: {
    &#39;list-page:add-page&#39;: &#39;slide&#39;,
    &#39;list-page:detail-page&#39;: &#39;flip&#39;
}
</code></pre>

<p>위 예는 list-page에서 add-page로 이동할 때는 slide 효과가, list-page에서 detail-page로 이동할 때는 flip 효과가 적용된다. 반대 방향의 효과를 지정하지 않아도 기본적으로 동일한 효과에서 방향만 반대로 나타나도록 설정된다. 즉, add-page에서 list-page로 이동할 때는 반대 방향의 slide 효과가, detail-page에서 list-page로 이동할 때는 반대 방향의 flip 효과가 적용된다. 물론, 반대 방향의 효과를 명시적으로 지정하면 그 설정이 우선한다.</p>

<p>애니메이션 효과의 속도를 조절하고 싶다면 다음과 같이 duration을 밀리초 단위로 지정하면 된다.</p>

<pre><code>transitions: {
    &#39;list-page:add-page&#39;: { type: &#39;slide&#39;, duration: 2000 },
    &#39;list-page:detail-page&#39;: &#39;flip&#39;
}
</code></pre>
