<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="./dist/lib/bootstrap/css/bootstrap.css" />
    <link rel="stylesheet" href="./dist/lib/bootstrap/css/bootstrap-responsive.css" />
    <link rel="stylesheet" href="./dist/ui/theme/white/css/cornerstone.css" />
    <style>#customers
#{
#      font-family:"Trebuchet MS", Arial, Helvetica, sans-serif;
#      width:100%;
#      border-collapse:collapse;
#}
td, th 
{
      font-size:1.2em;
      border:1px solid #98bf21;
      padding:3px 7px 2px 7px;
}
th 
{
      font-size:1.4em;
      text-align:left;
      padding-top:5px;
      padding-bottom:4px;
      background-color:#A7C942;
      color:#fff;
}
tr.alt td 
{
      color:#000;
      background-color:#EAF2D3;
}</style>
    <script src="./dist/lib/jquery-1.8.1.min.js"></script>
    <script src="./dist/ui/widget-plugins.js"></script>
  </head>
  <body>
    <div class="navbar ico-txt">
      <div class="navbar-inner">
        <div class="container">
          <button class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar">
            </span>
            <span class="icon-bar">
            </span>
            <span class="icon-bar">
            </span>
          </button>
          <a class="brand" href="./index.html">
            Cornerstone
          </a>
          <div class="nav-collapse collapse">
            <ul class="nav pull-left">
              <li class="inactive" id="home">
                <a href="./index.html" title="home">
                  HOME
                </a>
              </li>
              <li class="inactive" id="toc">
                <a href="./toc.html" title="toc">
                  목차
                </a>
              </li>
              <li class="inactive" id="bytag">
                <a href="./bytag.html" title="bytag">
                  태그별모음
                </a>
              </li>
              <li class="inactive" id="bydate">
                <a href="./bydate.html" title="bydate">
                  작성순모음
                </a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div class="container">
      <div class="row-fluid">
        <div class="span12">
          <article class="page" typeof="sioc:page" about="/RT_forPlugIn">
            <div class="page-content" property="sioc:content">
  <hr>

<h1>1. Cornerstone Runtime 기본구조</h1>

<hr>

<h2>1.1 공통 Runtime 기본구조</h2>

<p><img src="./images/extensionstructure.png" alt="Cornerstone Runtime 메인 구조"></p>

<ul>
<li><p>Cornerstone Runtime은 크게 platform 별 Native Layer와 Java Script Layer의 2가지의 layer로 나눠 진다. </p></li>
<li><p>Native layer는 각 플랫폼 별 Webview를 포함하여 사용한다. </p></li>
<li><p>Native layer는 각 플랫폼 별 사용되는 언어로 개발되어 있으며 JavaScript layer에서 요청된 DeviceAPI 를 플랫폼 SDK를 이용하여 처리된다.  </p></li>
</ul>

<p><br> </p>

<h3>1.1.1 Runtime JavaScript layer</h3>

<ul>
<li><p>Java Script layer는 웹앱에서 사용하기 위한 JavaScript API들을 선언 및 정의 하며 이를 Runtime의 native layer와 연결하는 역할을 한다.</p></li>
<li><p><strong>SRT-x.x.js</strong> 형태로 배포 되며 Runtime이 업데이트 될때마다 버전명이 올라간다. 
    &gt; <strong>2012.10.08</strong> 기준 <strong>SRT-1.0.js</strong> 배포 </p></li>
<li><p><strong>SRT-x.x.js</strong> 는 크게 두가지 역할로 구분된다. </p>

<ul>
<li>   DeviceAPIs : 웹앱에서 사용하는 JavaScript API ProtoType 정의 </li>
<li>   exec module: JavaScript APIs 를 Native Runtime Library와 연결하여 통신하는 공통 인터페이스 모듈 

<ul>
<li>   js prompt()함수를 native 단에서 재정의 하여 JavaScript와 native의 연결 통로가 된다.<br></li>
</ul></li>
</ul></li>
</ul>

<p><br></p>

<hr>

<h2>1.2 Android Runtime 기본 구조</h2>

<p><br></p>

<h3>1.2.1 Android Native Layer</h3>

<ul>
<li><p>Android Webview를 이용하여 Runtime JavaScript Library에서 호출된 API를 그에 해당하는 Native Class를 실행하고 성공/실패 콜백 전달하는 모듈</p></li>
<li><p>WebApp에서 Device의 특정 기능을 수행 및 webview를 사용하기 위하여 <strong>Runtime.jar</strong> 가 배포된다. </p>

<ul>
<li>   Runtime.jar는 Java class로 구성되어 있는 Android용 native library 이다. </li>
<li>    Runtime.jar는 web app의 index.html을 load하는 파일을 포함 하고 있다. </li>
<li>    Runtime.jar는 Cornerstone Runtime에서 제공하는 DeviceAPI가 포팅되어 있다. </li>
<li>    Runtime.jar는 Native code로 모듈화 되어 Android SDK 로 부터 작업을 수행하고 결과를 JavaScript layer에 반환 한다. </li>
</ul></li>
</ul>

<p><br></p>

<h3>1.2.2 Android Project Files</h3>

<ul>
<li><p>Android용 webapp을 개발하기 위해서는 아래 와 같은 project file 들을 세팅하여야 한다. </p>

<p>1) AndroidManifest.xml</p>

<ul>
<li>   WebApp의 고유한 <strong>package</strong> 명 설정 </li>
</ul>

<p>2) res/value/string.xml </p>

<ul>
<li>    실제 단말에서 보여지는 <strong>WebApp의 이름</strong> 설정 </li>
</ul>

<p>3)  res/drawable/icon.png</p>

<ul>
<li>    실제 단말에서 보여지는 <strong>아이콘</strong> 설정 </li>
</ul></li>
</ul>

<p><br></p>

<hr>

<h2>1.3 IOS Runtime 기본 구조</h2>

<h3>1.3.1 IOS Native Layer</h3>

<p><img src="./images/ios-Runtime-structure.png" alt=""></p>

<ul>
<li><p>UIWebview를 이용하여 Runtime JS Library에서 불리는 API를 그에 해당하는 Native Class를 실행하고 성공/실패 콜백 전달 모듈</p>

<ul>
<li>RuntimeDelegate : UIWebview를 생성하고 Runtime API를 연동</li>
<li>ViewController : UIWebview와 Device를 연결하고 Orientaion을 제어</li>
<li>Commands : JS API 를 Native Platform API를 통해서 구현</li>
<li>Utils : JSON / Base64 / ExtendMutableArray / ExtendMutableDictionary 라이브러리</li>
</ul></li>
<li><p>SRT.framework 라는 이름으로 배포된다.</p></li>
</ul>

<p><br></p>

<h3>1.3.2 IOS Project Files</h3>

<ul>
<li><p>iOS용 webapp을 개발하기 위해서는 아래 와 같은 project file 들을 세팅하여야 한다. </p>

<p>1) SRT_Template-Info.plist</p>

<ul>
<li><strong>iOS 어플 설정</strong>을 위한 프로젝트 파일</li>
</ul>

<p>2) SRT.plist</p>

<ul>
<li>   <strong>Cornerstone Runtime 설정</strong>을 위한 프로젝트 파일</li>
</ul>

<p>3) Resources</p>

<ul>
<li>   icon / splash screen 용 이미지 파일들</li>
</ul></li>
</ul>

<p><br></p>

<hr>

<h1>2. Cornerstone Runtime 확장 구조 개발</h1>

<hr>

<h2>2.1. 개요</h2>

<ul>
<li><p>WebApp은 Device Platform (Android, iOS..)에서 제공하는 Native SDK API를 사용할 수 없다. 따라서 WebApp에서 단말 기능을 사용하고자 한다면 브라우져 및 Runtime에서 제공하는 JavaScript Extension API를 사용하여야 한다. 이를 가능하게 하는것이 Cornerstone Runtime 이며 , 이 Cornerstone Runtime 내부에서 HTML5 Spec을 준수하는 API (contact , calendar, file .. etc) 와 추가적인 Additional API (audio, childBrowser..etc) 를 제공한다. </p></li>
<li><p>통신사 별 과금 처리와 같은 추가적인 API 를 WebApp에서도 사용하고자 한다면 선 개발된 Cornerstone Runtime에 Plugin 형태로 추가 개발 할 수 있다.  마찬가지로 Cornerstone Runtime에서 제공하지 않는 단말 접근 기능을 개발하고자 한다면 이 역시 plugin 형태로 확장 개발 할 수 있다.</p></li>
</ul>

<h2>2.2 Android Runtime 확장 구조 개발</h2>

<h3>2.2.1 Android Runtime 확장 구조 개발 환경</h3>

<p><img src="./images/devel.png" alt="Android Runtime 확장구조 개발 환경 구조"> </p>

<ul>
<li>   아래 링크를 통하여 확장구조 개발에 필요한 Android Native source와 JavaScript source 예제를 
참조할 수 있다. </li>
</ul>

<p><a href="./sample/Android_plugin_sample.zip" title="Android plugin 개발 예제 소스 ">./sample/Android_plugin_sample.zip</a></p>

<p>1) src - plugin 개발시에 작성하는 <strong>Java Native Code</strong></p>

<p>2) asset - 실제 웹앱의 웹 리소스(HTML/CSS/JS/IMG) 와 Runtime JavaScript Library 가 저장되는 위치 </p>

<ul>
<li>   <strong>assets/www</strong> : 웹앱의 저장 위치 </li>
<li>   <strong>assets/www/index.html</strong> : 웹앱의 첫 실행 파일 </li>
</ul>

<p>3) libs - Webview 를 이용하여 Device 의 단말 접근 기능을 제공하는 DeviceAPI가 포팅된 Android 
Library 위치 </p>

<ul>
<li>   <strong>Runtime.jar</strong> : webview 및 DeviceAPI가 포팅된 JAVA library</li>
</ul>

<p>4) drawable - device에 보여지는 icon 및 splash image를 저장하는 위치 </p>

<ul>
<li>   <strong>icon.png</strong> : device에 보여지는 icon</li>
<li>   <strong>splash.png</strong> : 웹앱 실행 초기에 보여지는 splash image (optional) </li>
</ul>

<p>5) values , xml - 웹앱의 name 및 runtime setting을 할 수 있는 폴더 </p>

<ul>
<li>   <strong>plugin.xml</strong> : plugin을 Runtime에 등록하는 파일 </li>
<li>   <strong>value/string.xml</strong> : 웹앱의 name을 세팅하는 파일 </li>
<li>   <strong>xml/config.xml</strong> : device의 orientation(portrait , landscape , audo) 및 splash image를 세팅 하는 파일 </li>
</ul>

<p>6) AndroidManifest.xml : 하나의 Native Application으로써의 고유한 Package 명을 지정하는 파일, 하드웨어 가속 GPU 렌더링 사용여부를 지정하는 파일.</p>

<p><br></p>

<h3>2.2.2 Android Runtime 확장 구조 개발 절차</h3>

<p><strong>step 1.</strong>  Authoring tool을 이용해 Android Web App Template를 받으면 Lib 폴더에 <strong>Runtime.jar가 기본으로 포함</strong>되어 있다.</p>

<p><img src="./images/src.png" alt=""></p>

<p><strong>step 2.</strong>  확장 구조 개발자는 아래의 그림과 같이 src 폴더의 .java 파일에 추가할 native 모듈에 대한 정의를 한다. </p>

<p><img src="./images/extension1.png" alt=""></p>

<ul>
<li><p>src 폴더를 생성한다. </p></li>
<li><p>package 명을 지정한다. 이는 plugin.xml에 입력될 값이다. </p>

<blockquote>
<p>example - co.kr.skr.plugin    </p>
</blockquote></li>
<li><p>native 모듈을 개발을 위한 .java 파일을 생성한다. </p>

<ul>
<li>   Plugin class 를 <strong>extends</strong> 한다. </li>
<li>   <strong>execute</strong> 함수를 재정의 한다. </li>
</ul>

<blockquote>
<p>example code </p>
</blockquote>

<pre><code>public class pluginEx extends Plugin{

    @Override
    public PluginResult execute(String arg0, JSONArray arg1, String callbackId) {

        // TODO Auto-generated method stub

        return null;
    }
}
</code></pre></li>
<li><p>execute 함수 내부에 native api를 이용하여 특정 기능을 구현 한다. </p>

<ul>
<li><p>return 형은 PluginResult 이다. PluginResult 객체에 status와 필요하다면 JavaScript에 전달 할 message를 입력한다. </p>

<p>1) 특정 기능이 성공적으로 완료된 경우 (JavaScript SuccessCallback 호출)  </p>

<p><code>return new PluginResult(Status.OK, returnObj);</code></p>

<p>2) 특정 기능이 실패 한 경우 (JavaScript ErrorCallback 호출)  </p>

<p><code>return new PluginResult(Status.ERROR, errorObj);</code></p>

<p>3) 별도의 JavaScript 알림이 필요 없는 경우 </p>

<p><code>return new PluginResult(Status.NO_RESULT);</code></p></li>
</ul>

<blockquote>
<p>example code (MacAddress plugin)</p>
</blockquote>

<pre><code>    @Override
    public PluginResult execute(String action, JSONArray args, String callbackId) {

        this.callbackId = callbackId;

        //action은 JavaScript에서 정의한 extension api 명이다. 

        //device의 MacAddress를 얻는 기능 
        if(action.equalsIgnoreCase(&quot;getMacAddress&quot;)){        
            WifiInfo wifiInfo = wifiManager.getConnectionInfo();
            String macAddress = wifiInfo.getMacAddress();

            PluginResult result = new PluginResult(PluginResult.Status.OK, macAddress);
            return result;
        }
        else if(action.equalsIgnoreCase(&quot;getDeviceID&quot;)){        
            String android_id = Secure.getString(ctx.getContentResolver(), Secure.ANDROID_ID);

            PluginResult result = new PluginResult(PluginResult.Status.OK, android_id);
            return result;
        }
        //device의 개통된 번호를 얻는 기능 
        else if(action.equalsIgnoreCase(&quot;getPhoneNumber&quot;)){
            String phoneNumber = tm.getLine1Number();
            return new PluginResult(PluginResult.Status.OK, phoneNumber);
        }

        return new PluginResult(PluginResult.Status.NO_RESULT);
    }
</code></pre></li>
<li><p><strong>setContext</strong> 함수를 재정의 하여 plugin 로딩시 초기화 작업 및 API가 호출되기 전의 특정 작업을 수행 할 수 있다. </p>

<blockquote>
<p>example code (MacAddress plugin)</p>
</blockquote>

<pre><code>    @Override
    public void setContext(RuntimeInterface ctx) {
        // TODO Auto-generated method stub
        super.setContext(ctx);

        wifiManager = (WifiManager)ctx.getSystemService(Context.WIFI_SERVICE);
        tm = (TelephonyManager) ctx.getSystemService(Context.TELEPHONY_SERVICE);
    }
</code></pre></li>
<li><p><strong>isSynch</strong> 함수를 재정의 하여 특정 API에 대하여 동기적으로 동작하게 함수를 개발 할 수 있다. 특정 api에 대하여 재정의 하지 않는다면 API는 비동기로 동작한다. </p>

<blockquote>
<p>example code (MacAddress plugin)</p>
</blockquote>

<pre><code>    @Override
        public boolean isSynch(String action) {
            //getMacAddress api는 동기적으로 동작 
            if(action.equals(&quot;getMacAddress&quot;))
                return true;
            else if(action.equals(&quot;getDeviceID&quot;))
                return true;
            else if(action.equals(&quot;getPhoneNumber&quot;))
                return true;

            return super.isSynch(action);
        }
</code></pre></li>
<li><p><strong>execute</strong> 함수의 3번째 매개변수(callbackId)를 이용하여 JavaScript callback에 Native에서 pluginResult 객체를 지속적으로 return 할 수 있다. </p>

<blockquote>
<p>example code ( Plugin.success() api를 이용하여 callback을 보내는 방법) </p>
</blockquote>

<pre><code>@Override
public PluginResult execute(String action, JSONArray args, String callbackId) {
JSONObject obj = args.optJSONObject(0);    

    if(action.equalsIgnoreCase(&quot;for&quot;)){

        int end = obj.optInt(&quot;end&quot;);        
        int i = obj.optInt(&quot;start&quot;);

        //현재 action에 대한 callback ID를 내부에 저장한다. 
        this.callbackId = callbackId;
        threadstop = false;

        do{
            i++;
            if(i%1000 == 0){
                PluginResult result = new PluginResult(PluginResult.Status.OK, i);

                // result를 setKeepCallback(true) 로 설정한다. 
                // 위와 같이 설정 하면 JS library에서 callback을 delete 하지 않는다. 
                // default는 false이다. 
                result.setKeepCallback(true);    

                // action에 대한 calbakcId에 result를 지속적으로 보낼 수 있다. 
                this.success(result, this.callbackId);
            }
            else if(i == end){
                threadstop = true;
                PluginResult result = new PluginResult(PluginResult.Status.OK, &quot;stop&quot;);

                // result를 setKeepCallback(false) 로 설정한다
                result.setKeepCallback(false);            
                // action에 대한 calbakcId에 result를 마지막으로 보낸다.
                // result의 keepCallback이 false이기 때문에 JS lib에서 callback을 delete한다. 
                this.success(result, this.callbackId);
            }    

        }while(!threadstop);
    }

    return new PluginResult(PluginResult.Status.NO_RESULT);
}
</code></pre></li>
</ul>

<p><strong>step 3.</strong>  확장 구조 개발자는 아래의 그림과 같이 asset 폴더의 .js 파일에 추가할 JavaScript 모듈에 대한 정의를 한다. </p>

<p><img src="./images/jsextension.png" alt=""></p>

<ul>
<li><p>asset 폴더 내에 JavaScript plugin 을 위한 .js 파일을 생성한다. </p></li>
<li><p>JavaScript plugin 객체를 생성한다.</p>

<blockquote>
<p>code example</p>
</blockquote>

<p><code>var MacAddress = function() {};</code></p></li>
<li><p>JavaScript Extension API 의 prototype을 정의 한다. </p>

<blockquote>
<p>code example 1 (SuccessCallback, ErrorCallback , 매개변수가 없는 api) </p>
</blockquote>

<pre><code>MacAddress.prototype.getMacAddress = function() {
//do sync
var macAddress = srt.exec(null, null, &#39;MacAddress&#39;, &#39;getMacAddress&#39;, []);
return macAddress;
};
</code></pre>

<blockquote>
<p>code example 2 (SuccessCallback, ErrorCallback , 매개변수가 있는 api) </p>
</blockquote>

<pre><code>MacAddress.prototype.list = function(successCallback, failureCallback,params) {
srt.exec(successCallback, failureCallback, &#39;MacAddress&#39;, &#39;list&#39;, [ params ]);
};
</code></pre></li>
<li><pre><code>JavaScript plugin 객체를 Cornerstone Runtime JavaScript Library의 plugin으로 등록 한다. 
</code></pre>

<blockquote>
<p>code example </p>
</blockquote>

<pre><code>srt.addConstructor(function() {
    //window.plugin.MacAddress 로 javascript 에 노출 된다. 
    srt.addPlugin(&#39;MacAddress&#39;, new MacAddress());
});
</code></pre></li>
</ul>

<blockquote>
<p>Full Example (MacAddressPlugin.js) </p>
</blockquote>

<pre><code>var MacAddress = function() {};

MacAddress.prototype.getMacAddress = function() {
    //do sync
    var macAddress = srt.exec(null, null, &#39;MacAddress&#39;, &#39;getMacAddress&#39;, []);
    return macAddress;
};

MacAddress.prototype.list = function(successCallback, failureCallback,params) {
    srt.exec(successCallback, failureCallback, &#39;MacAddress&#39;, &#39;list&#39;, [ params ]);
    };

MacAddress.prototype.getDeviceID = function() {
    //do sync
    var deviceID = srt.exec(null, null, &#39;MacAddress&#39;, &#39;getDeviceID&#39;, []);
    return deviceID;
};

srt.addConstructor(function() {
    srt.addPlugin(&#39;MacAddress&#39;, new MacAddress());
});
</code></pre>

<p><strong>step 4.</strong>  플러그 인을 Runtime에 등록하고자 할 때에는 개발한 plugin 이름과 실제 구현된 java파일 위치를 <strong>res/xml/plugin.xml</strong> 파일에 작성한다.</p>

<p><img src="./images/config.png" alt=""></p>

<ul>
<li>   name 은 JavaScript 등록을 위해 srt.addPlugin() 에 등록되었던 이름이다. </li>
<li><p>value 는 실제 Java 파일이 작성된 package의 full path 이다. </p>

<blockquote>
<p>plugin.xml </p>
</blockquote>

<pre><code>`&lt;plugin name=&quot;MacAddress&quot; value=&quot;co.kr.skr.plugin.MacAddressPlugin&quot; /&gt;`
</code></pre>

<p><code>&lt;plugin name=&quot;CallLog&quot; value=&quot;org.skt.runtime.plugin.CallLogPlugin&quot; /&gt;</code></p></li>
</ul>

<p><strong>step 5.</strong> 웹앱의 시작 파일은 반드시 index.html 이어야 한다. <strong>SRT-1.0.js는 플러그인 개발 환경 template의 기본 포함된 파일</strong>이다. </p>

<p><img src="./images/src2.png" alt=""></p>

<ul>
<li><p>특정 웹페이지 내부에서 DeviceAPI를 사용하고 할 때에는 아래와 같이 JavaScript Library를 선언한다.</p>

<p><code>&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=*../path/SRT-0.1.js&quot;&gt;&lt;/script&gt;</code></p></li>
<li><p>특정 웹페이지 내부에서 추가된 Plugin을 사용하고 할 때에는 아래와 같이 JavaScript Library를 선언한다.</p></li>
</ul>

<blockquote>
<p>Example 1. MacAddress Plugin 사용 예제 </p>
</blockquote>

<pre><code>    &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;../path/macaddressplugin.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    function getMacAddress(){
        var macAddress = window.plugins.MacAddress.getMacAddress();
        alert(&quot;MacAddress = &quot; + macAddress);
    }
    function getPhoneNumber(){
        var phoneNumber = window.plugins.MacAddress.getPhoneNumber();
        alert(&quot;phoneNumber = &quot; + phoneNumber);
    }
    function getDeviceID(){
        var id = window.plugins.MacAddress.getDeviceID();
        alert(&quot;Device id = &quot; + id);
    }
    &lt;/script&gt;
</code></pre>

<blockquote>
<p>Example 2. CallLog Plugin 사용 예제 </p>
</blockquote>

<pre><code>    &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;../path/calllogplugin.js&quot;&gt;&lt;/script&gt;
    &lt;title&gt;CallLog Test&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;

    function calllogSC(obj){
        if (obj.length &gt; 0) {
                alert(obj[0].number);
                alert(obj[0].duration);
            } else {
                alert(&quot;empty call log&quot;);
            }
    }
    function errorcallback(e) {
        alert(e);
    }
    function getCallLogs() {
        window.plugins.CallLog.list(calllogSC, errorcallback, &quot;day&quot;);
    }
    &lt;/script&gt;
</code></pre>

<p><strong>step 6.</strong>  Res 폴더 내부에 웹앱 개발자가 사용하고자 하는 아이콘 이미지를 <strong>icon.png</strong>의 이름으로 삽입한다. </p>

<p><img src="./images/icon.png" alt=""></p>

<p><strong>step 7.</strong> AndroidManifest.xml 파일 내부의 package 명을 개발자가 변경을 해줘야 한다. 이는 고유한 값으로 Android 시스템 내부의 중복된 어플이 설치되지 않도록 한다. </p>

<p><img src="./images/manifest.png" alt=""></p>

<ul>
<li><p>기본적인 Manifest 파일의 형식 </p>

<pre><code>&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:windowSoftInputMode=&quot;adjustPan&quot;
package=&quot;co.kr.skt.testapp.test&quot; android:versionName=&quot;1.1&quot; android:versionCode=&quot;5&quot;&gt;
</code></pre></li>
<li><p>GPU 하드웨어 가속 렌더링을 사용하고 싶다면 아래와 같이 application tag에 hardwareAccelerated 를 true로 설정 한다. 이는 웹 앱이 디바이스에서 사용하는 메모리 점유율을 늘어나지만 부드러운 2D image 렌더링을 가능하게 한다. (default는 생략됨) </p>

<pre><code>&lt;application android:icon=&quot;@drawable/icon&quot; android:label=&quot;@string/app_name&quot; android:hardwareAccelerated=&quot;true&quot; android:debuggable=&quot;true&quot;&gt;
</code></pre></li>
</ul>

<p><strong>step 8.</strong> Application의 실제 단말기에서 보여지는 이름을 <strong>string.xml의 app_name</strong>에 정의한다.</p>

<p><img src="./images/string.png" alt=""></p>

<ul>
<li><p>string.xml</p>

<pre><code>&lt;resources&gt;
  &lt;string name=&quot;app_name&quot;&gt;테스트웹앱&lt;/string&gt; 
&lt;/resources&gt;
</code></pre></li>
</ul>

<p><strong>step 9.</strong> Eclipse의 빌드 아이콘을 이용하여 Android App을 빌드하여 Device에 정상적으로 설치됨을 확인한다. </p>

<p><img src="./images/webapp.png" alt=""></p>

<p><strong>step 10.</strong> Device에 WebApplication이 정상적으로 출력됨을 확인한다. </p>

<h2>2.3 iOS Runtime 확장 구조 개발</h2>

<h3>2.3.1 iOS Runtime 확장 구조 개발 환경</h3>

<p><img src="./images/srt_project.png" alt=""> </p>

<ul>
<li>   아래 링크를 통하여 확장구조 개발에 필요한 iOs Native source와 JavaScript source 예제를 
참조할 수 있다. </li>
</ul>

<p><a href="./sample/iOS_plugin_sample.zip" title="iOS plugin 개발 예제 소스 ">./sample/iOS_plugin_sample.zip</a></p>

<p>1) SRT.framework - Cornerstone Runtime Library</p>

<p>2) www - 실제 웹앱의 웹 리소스(HTML/CSS/JS/IMG) 와 Cornerstone Runtime JavaScript Library 가 저장되는 위치 </p>

<ul>
<li>   <strong>www</strong> : 웹앱의 저장 위치 </li>
<li>   <strong>www/index.html</strong> : 웹앱의 첫 실행 파일</li>
<li>   <strong>www/SRT-1.0.js</strong> : Cornerstone Runtime JavaScript Library</li>
</ul>

<p>3) SRT_Template/Resources - 어플에 필요한 리소스를 저장하는 위치</p>

<ul>
<li>   <strong>icons</strong> : Icon을 위한 이미지 폴더</li>
<li>   <strong>splash</strong> : splash screen을 위한 이미지 폴더</li>
</ul>

<p>4) SRT_Template/Supporting Files - 앱 및 런타임 설정 파일이 위치하는 폴더</p>

<ul>
<li>   <strong>SRT_Template-Info.plist</strong> : iOS 앱을 위한 설정 파일</li>
<li>   <strong>SRT.plist</strong> : Cornerstone Runtime을 위한 설정 파일</li>
<li>   <strong>Plugins</strong> : 확장구조를 위한 폴더</li>
</ul>

<p><br></p>

<h3>2.3.2 iOS Runtime 확장 구조 개발 절차</h3>

<p><strong>step 1.</strong>  Authoring tool을 이용해 iOS SRT_Template를 받아서 SRT_Template.xcodeproj 파일을 연다</p>

<p><img src="./images/openproject.jpg" alt=""></p>

<p><strong>step 2.</strong>  확장 구조 개발자는 아래의 그림과 같이 SRT_Template/Plugins 에 추가할 native 모듈에 대한 정의를 한다. </p>

<p><img src="./images/plugin-c.png" alt=""></p>

<ul>
<li><p>native 모듈을 개발을 위한 Objective-C 헤더 파일을 생성한다. </p>

<ul>
<li>   SRT Framework의  RTPlugin.h 파일을 import 한다.</li>
<li>   클래스 생성시 RTPlugin class 를 상속 받는다.</li>
<li><p>Javascript에서 불리울 함수를 선언한다. 함수 파라메터는 아래와 같다.</p>

<pre><code>-(void)FUNCTIONNAME:(NSMutableArray*)arguments withDict:(NSMutableDictionary*)options;
</code></pre></li>
</ul>

<blockquote>
<p>full example code (RTPageLoading.h)</p>
</blockquote>

<pre><code>    #import &lt;SRT/RTPlugin.h&gt;

    @interface RTPageLoading : RTPlugin {

    }

    -(void) getStartPageLoadingTime:(NSMutableArray*)arguments withDict:(NSMutableDictionary*)options;

    @end
</code></pre></li>
<li><p>native 모듈을 개발을 위한 Objective-C 소스 파일을 생성한다.</p>

<ul>
<li><p>헤더에서 선언한 함수를 정의한다.</p>

<p>1) Javascript에서 array 형식으로 파라메터 전달시에는 NSMutableArray* <strong>arguments</strong> 로 전달 된다.</p>

<p>2) Javascript에서 구조체 형식으로 파라메터 전달시에는 NSMutableDictionary* <strong>options</strong> 로 전달 된다.</p></li>
<li><p>return 형은 RTPluginResult 이다. RTPluginResult 객체에 status와 message를 담는다. message는 생략 가능하다.</p>

<p>1) status : 성공 , message : double형태로 전달인 경우  </p>

<pre><code>RTPluginResult* result = [RTPluginResult resultWithStatus:RTCommandStatus_OK messageAsDouble:123456.789];
</code></pre>

<p>2) status : 성공 , message : dictionary 형태로 전달인 경우 </p>

<pre><code>RTPluginResult* result = [RTPluginResult resultWithStatus:RTCommandStatus_OK messageAsDictionary:anydict];
</code></pre>

<p>3) status : 실패 인 경우</p>

<pre><code>RTPluginResult* result = [RTPluginResult resultWithStatus:RTCommandStatus_ERROR];
</code></pre></li>
<li><p>Accelerometer와 같이 지속적으로 콜백을 호출하는 경우에는 RTPluginResult에 setKeepCallback API를 호출하여 설정 한다. 설정하지 않으면 콜백은 1회성으로만 전달된다.</p>

<pre><code>[result setKeepCallback:[NSNumber numberWithBool:YES]];
</code></pre></li>
<li><p>RTPluginResult 타입은 writeJavascript 함수를 통해 자바스크립트로 전달 가능하다.   callbackID를 이용하여 호출자로 전달하며 callbackID는 arguments array의 첫번째 값이며 NSString 형태로 전달 된다. </p>

<p>1) callback id를 전달 받는 경우</p>

<pre><code>NSString* callbackId = [arguments objectAtIndex:0];
</code></pre>

<p>2) 호출자(javascript api)의 성공 콜백을 부르는 경우</p>

<pre><code>[super writeJavascript:[result toSuccessCallbackString:callbackId]]; 
</code></pre>

<p>3) 호출자(javascript api)의 실패 콜백을 부르는 경우</p>

<pre><code>[super writeJavascript:[result toErrorCallbackString:callbackId]];
</code></pre></li>
</ul>

<blockquote>
<p>full example code (RTPageLoading.m)</p>
</blockquote>

<pre><code>    #import &quot;RTPageLoading.h&quot;

    @implementation RTPageLoading

    -(void) getStartPageLoadingTime:(NSMutableArray*)arguments withDict:(NSMutableDictionary*)options {
        NSString* callbackId = [arguments objectAtIndex:0];
        RTPluginResult* result = [RTPluginResult resultWithStatus:RTCommandStatus_OK messageAsDouble:123456.789];
        [super writeJavascript:[result toSuccessCallbackString:callbackId]]; 
    }

    @end

}
</code></pre></li>
</ul>

<p><strong>step 3.</strong>  확장 구조 개발자는 아래의 그림과 같이 www 폴더의 .js 파일에 추가할 JavaScript 모듈에 대한 정의를 한다. </p>

<p><img src="./images/plugin-js.png" alt=""></p>

<ul>
<li><p>asset 폴더 내에 JavaScript plugin 을 위한 .js 파일을 생성한다. </p></li>
<li><p>JavaScript plugin 객체를 생성한다.</p>

<blockquote>
<p>code example</p>
</blockquote>

<p><code>var PageLoading = function() {};</code></p></li>
<li><p>JavaScript Extension API 의 prototype을 정의 한다. </p>

<blockquote>
<p>code example 1 (SuccessCallback, ErrorCallback , 매개변수가 없는 api) </p>
</blockquote>

<pre><code>PageLoading.prototype.getStartPageLoadingTime = function() {
    srt.exec(null, null, &#39;PageLoading&#39;, &#39;getStartPageLoadingTime&#39;, []);
};
</code></pre>

<blockquote>
<p>code example 2 (SuccessCallback, ErrorCallback , 매개변수가 있는 api) </p>
</blockquote>

<pre><code>PageLoading.prototype.list = function(successCallback, failureCallback,params) {
    srt.exec(successCallback, failureCallback, &#39;PageLoading&#39;, &#39;list&#39;, [ params ]);
};
</code></pre></li>
<li><pre><code>JavaScript plugin 객체를 Cornerstone Runtime JavaScript Library의 plugin으로 등록 한다. 
</code></pre>

<blockquote>
<p>code example </p>
</blockquote>

<pre><code>srt.addConstructor(function() {
    //window.plugin.PageLoading 로 javascript 에 노출 된다. 
    srt.addPlugin(&#39;PageLoading&#39;, new PageLoading());
});
</code></pre></li>
</ul>

<blockquote>
<p>Full Example (PageLoading.js) </p>
</blockquote>

<pre><code>var PageLoading = function() {};

PageLoading.prototype.getStartPageLoadingTime = function() {
    srt.exec(null, null, &#39;PageLoading&#39;, &#39;getStartPageLoadingTime&#39;, []);
};

PageLoading.prototype.list = function(successCallback, failureCallback,params) {
    srt.exec(successCallback, failureCallback, &#39;PageLoading&#39;, &#39;list&#39;, [ params ]);
};

srt.addConstructor(function() {
    srt.addPlugin(&#39;PageLoading&#39;, new PageLoading());
});
</code></pre>

<p><strong>step 4.</strong>  플러그 인을 Runtime에 등록하고자 할 때에는 개발한 js plugin 이름과 실제 구현된 Objective-C 클래스 이름을 SRT.plist 의 Plugins 의 Key / Value로 등록한다</p>

<p><img src="./images/SRT_plugin.jpg" alt=""></p>

<ul>
<li>   key 는 JavaScript 등록을 위해 srt.addPlugin() 에 등록되었던 이름이다. </li>
<li><p>value 는 plugin Objective-c 클래스 명이다.  </p>

<blockquote>
<p>plugin.xml </p>
</blockquote>

<pre><code>&lt;key&gt;Plugins&lt;/key&gt;
    &lt;dict&gt;
        &lt;key&gt;PageLoading&lt;/key&gt;
        &lt;string&gt;RTPageLoading&lt;/string&gt;
    &lt;/dict&gt;
</code></pre></li>
</ul>

<p><strong>step 5.</strong> 웹앱의 시작 파일은 반드시 index.html 이어야 한다. <strong>SRT-1.0.js는 template 기본 파일</strong>이다. </p>

<p><img src="./images/index.jpg" alt=""></p>

<ul>
<li><p>특정 웹페이지 내부에서 DeviceAPI를 사용하고 할 때에는 아래와 같이 JavaScript Library를 선언한다.</p>

<p><code>&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=SRT-0.1.js&quot;&gt;&lt;/script&gt;</code></p></li>
<li><p>특정 웹페이지 내부에서 추가된 Plugin을 사용하고 할 때에는 아래와 같이 JavaScript Library를 선언한다.</p>

<p><code>&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;pageloadingplugin.js&quot;&gt;&lt;/script&gt;</code></p></li>
</ul>

<blockquote>
<p>Full Example 1. PageLoading Plugin(index.html) 사용 예제 </p>
</blockquote>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;ko&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;meta name=&quot;viewport&quot; context=&quot;width-divice-width, initial-scele-1.0, user-scalble=no&quot;&gt;
&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;SRT-1.0.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;pageloadingplugin.js&quot;&gt;&lt;/script&gt;
&lt;title&gt;PageLoadingPlugin&lt;/title&gt;
&lt;script type=&quot;text/javascript&quot;&gt;

function startLoadingTimeTest(){
    function sc(time){
        alert(time + &quot; milliseconds&quot;);
    }

    function ec(){
        alert(&quot;error&quot;);
    }
    window.plugins.PageLoading.getStartPageLoadingTime(sc,ec);
}

&lt;/script&gt;
&lt;/head&gt;

&lt;hr&gt; PageLoadingPlugin API Test&lt;BR&gt;
&lt;button onclick=&quot;startLoadingTimeTest();&quot;&gt;startLoadingTimeTest&lt;/button&gt;&lt;br&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<blockquote>
<p>Example 2. CallLog Plugin 사용 예제 </p>
</blockquote>

<pre><code>    &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;../path/calllogplugin.js&quot;&gt;&lt;/script&gt;
    &lt;title&gt;CallLog Test&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;

    function calllogSC(obj){
        if (obj.length &gt; 0) {
                alert(obj[0].number);
                alert(obj[0].duration);
            } else {
                alert(&quot;empty call log&quot;);
            }
    }
    function errorcallback(e) {
        alert(e);
    }
    function getCallLogs() {
        window.plugins.CallLog.list(calllogSC, errorcallback, &quot;day&quot;);
    }
    &lt;/script&gt;
</code></pre>

<p><strong>step 6.</strong>  Resources/icons 폴더 내부에 웹앱 개발자가 사용하고자 하는 아이콘 이미지를 프로젝트에 추가한다. 기본으로 설정된 icon 파일 이름은 <strong>icon</strong>이며 기본 설정일 경우 단말에 따라 적용되는 icon 파일 이름은 아래와 같다. icon 파일 이름 설정 방법은 step 5. 에서 다룬다.</p>

<ul>
<li><strong>icon.png</strong> : Iphone 3GS 이전 모델 용 아이콘 이미지</li>
<li><strong><a href="mailto:icon@2x.png">icon@2x.png</a></strong> : iphone 4/4s 용 아이콘 이미지</li>
<li><strong>icon-72.png</strong> : ipad / ipad2 용 아이콘 이미지</li>
<li><strong><a href="mailto:icon-72@2x.png">icon-72@2x.png</a></strong> : new ipad 용 아이콘 이미지</li>
</ul>

<p><img src="./images/srt_resources.jpg" alt=""></p>

<p><strong>step 7.</strong> Resources/splash 폴더 내부에 웹앱 개발자가 사용하고자 하는 스플래쉬 이미지를 추가한다.  기본으로 설정된 splash 파일 이름은 <strong>Splash</strong>이며 기본 설정일 경우 단말에 따라 적용되는 splash 파일 이름은 아래와 같다. splash 파일 이름 설정 방법은 step 6.에서 다룬다 </p>

<p>참고로 스플래쉬 이미지란 웹앱 실행시 웹앱이 로딩될때까지 보여지는 이미지 화면을 뜻한다.</p>

<ul>
<li><strong>Splash.png</strong> : Iphone 3GS 이전 모델용 스플래쉬 이미지</li>
<li><strong>Splash @2x.png</strong> : iphone 4/4s 용 스플래쉬 이미지</li>
<li><strong>Splash-Landscape.png</strong> : ipad / ipad2 용 가로 스플래쉬 이미지</li>
<li><strong>Splash-Portrait.png</strong> : ipad / ipad2 용 세로 스플래쉬 이미지</li>
<li><strong><a href="mailto:Splash-Landscape@2x.png">Splash-Landscape@2x.png</a></strong> : new ipad 용 가로 스플래쉬 이미지</li>
<li><strong><a href="mailto:Splash-Portrait@2x.png">Splash-Portrait@2x.png</a></strong> : new ipad 용 세로 스플래쉬 이미지</li>
</ul>

<p><strong>step 8.</strong> Supporting Files/SRT_Template-Info.plist 파일을 수정하여 어플의 여러 속성 설정이 가능하다. 이는 Cornerstone Runtime 프로젝트 뿐만이 아니라 iOS 어플 공통 적용사항이다. 아래는 주요 설정 값들이다.</p>

<p><img src="./images/SRTTemplate_info.jpg" alt=""></p>

<ul>
<li><strong>Bundle display name</strong> : 어플명</li>
<li><strong>Icon files / Icon files(iOS5)</strong> : 아이콘 이미지 파일 이름명</li>
<li><strong>Bundle identifier</strong> : 어플 고유 ID. 실제 단말 연동을 위해서는 애플사에 개발자 인증(provisioning profile)을 받아야하며 그때 설정한 ID를 넣는다.</li>
<li><strong>Supported interface orientations / Supported interface orientations(ipad)</strong> : 해당 어플이 지원하는 화면 회전 허용값. 예를 들어 Portrait(bottom home button)만이 설정되어 있다면 iPAD에서 회전을 하여도 실제로 화면이 회전되지 않는다.</li>
</ul>

<p><strong>step 9.</strong> Supporting Files/SRT.plist 파일을 수정하여 Cornerstone Runtime의 여러 속성 설정이 가능하다. </p>

<p><img src="./images/SRT.jpg" alt=""></p>

<ul>
<li><strong>UIWebViewBounce</strong> : 화면 드래그를 끝까지 했을 경우 웹뷰가 바운스 효과를 내는지 여부를 설정함.</li>
<li><strong>EnableLocation</strong> : 해당 어플이 Geolocation 을 설정할수 있는지 여부를 설정</li>
<li><strong>EnableViewportscale</strong> : 뷰포트 확대/축소 허용 여부를 설정</li>
<li><strong>AutoHideSplashScreem</strong> : Yes일 경우 DeviceReady가 되면 자동으로 스플래쉬 스크린이 해제된다. No일 경우 API를 통해서 원하는 시점에 해제가 가능하다</li>
<li><strong>SplashImage</strong> : 스플래쉬 스크린을 위한 이미지 파일명 설정. 기본은 &ldquo;Splash&quot;로 설정되어 있다.</li>
<li><strong>Plugins</strong> : Cornerstone Runtime JS 라이브러리와 Native Class간의 연동을 위한 Map이다.
Key의 경우 JS 라이브러리를 위한 모듈명이며 Value의 경우 NativeClass 모듈명이다.
3rd 파티 개발자가 추가 플러그인을 개발할 경우에 사용한다.</li>
<li><strong>InstalledApplications</strong> : AppLauncher 모듈의 getInstalledApplications API 사용시 검색 가능한 어플리스트. 개발자가 어플리스트를 설정하면 getInstalledApplications API를 통해 어플 리스트중 실제 단말에 설치된 어플의 리스트를 가져올 수 있다. 어플리스트는 불려지는 어플에 설정된 URL Schemes에 설정된 값으로 리스트를 설정한다. 기본 설정은 기본 탑재 어플인 music, sms, mailto, videos 4가지가 설정되어 있다. </li>
</ul>

<p><strong>step 10.</strong> Run을 눌러서 실제 단말에서 웹앱이 정상적으로 실행되는지 확인한다. </p>

<p><img src="./images/run.png" alt=""></p>

</div>

          </article>
        </div>
      </div>
    </div>
<script  src="/socket.io/socket.io.js"></script><script >var socket = io.connect('/docpad-live-reload');
socket.on('regenerated',function(){
	document.location.reload();
});</script><script defer="defer"  src="./script.js"></script>  </body>
</html>
